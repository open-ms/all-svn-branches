// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2010 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Clemens Groepl $
// $Authors: Marc Sturm, Clemens Groepl $
// --------------------------------------------------------------------------
#include <OpenMS/FORMAT/MzMLFile.h>
#include <OpenMS/FORMAT/ConsensusXMLFile.h>
#include <OpenMS/FORMAT/FeatureXMLFile.h>
#include <OpenMS/FORMAT/IdXMLFile.h>
#include <OpenMS/FORMAT/FileHandler.h>
#include <OpenMS/FORMAT/FileTypes.h>
#include <OpenMS/FORMAT/TransformationXMLFile.h>
#include <OpenMS/ANALYSIS/MAPMATCHING/MapAlignmentAlgorithm.h>


#include <OpenMS/APPLICATIONS/TOPPBase.h>

using namespace OpenMS;
using namespace std;

//-------------------------------------------------------------
//Doxygen docu
//-------------------------------------------------------------

/**
	@page TOPP_MapAligner MapAligner

	@brief Corrects retention time distortions between maps.

<CENTER>
	<table>
		<tr>
			<td ALIGN = "center" BGCOLOR="#EBEBEB"> potential predecessor tools </td>
			<td VALIGN="middle" ROWSPAN=3> \f$ \longrightarrow \f$ MapAligner \f$ \longrightarrow \f$</td>
			<td ALIGN = "center" BGCOLOR="#EBEBEB"> potential successor tools </td>
		</tr>
		<tr>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=1> @ref TOPP_FeatureFinder </td>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=2> @ref TOPP_FeatureLinker </td>
		</tr>
		<tr>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=1> @ref TOPP_IDMapper </td>
		</tr>
	</table>
</CENTER>


	This tool provides several different algorithms to correct for retention time shifts and distortions. (Click on the links to get detailed documentation for each algorithm. Scroll down a bit for the parameter description.)

	- @ref OpenMS::MapAlignmentAlgorithmPoseClustering "pose_clustering_affine": The pose clustering algorithm as described in doi:10.1093/bioinformatics/btm209 is used to find an affine transformation.  This algorithm can be applied to features (featureXML) and peaks (mzML), but it has mostly been developed and tested on features.
	- @ref OpenMS::MapAlignmentAlgorithmIdentification "identification": An alignment algorithm based on peptide identifications, and thus applicable to files containing peptide IDs (idXML, annotated mzML/featureXML/consensusXML). It finds peptide sequences that different input files have in common and uses them as points of correspondence. From the retention times of these peptides, smooth non-linear transformations are computed that convert each file to a consensus time scale.
	- @ref OpenMS::MapAlignmentAlgorithmApplyGivenTrafo "apply_given_trafo": Applies transformations that are read from the files provided with the option @p given_transformations. These transformations might have been generated by a previous invocation of MapAligner, see the option @p transformations.  However, the trafoXML file format is not very complicated, so it is relatively easy to write (or generate) your own files.  This algorithm can be applied to mzML, featureXML, consensusXML, and idXML data.
	- @ref OpenMS::MapAlignmentAlgorithmSpectrumAlignment "spectrum_alignment": An experimental algorithm based on spectrum alignment; applicable only to peak maps (mzML).

	<B>The command line parameters of this tool are:</B>
	@verbinclude TOPP_MapAligner.cli

*/

// We do not want this class to show up in the docu:
/// @cond TOPPCLASSES

class TOPPMapAligner
  : public TOPPBase
{

public:
	TOPPMapAligner()
		: TOPPBase("MapAligner","Corrects retention time distortions between maps.")
	{
	}

protected:
	void registerOptionsAndFlags_()
	{
		String formats = "mzML,featureXML,consensusXML,idXML";
		registerInputFileList_("in","<files>",StringList(),"input files separated by blanks",true);
		setValidFormats_("in",StringList::create(formats));
		registerOutputFileList_("out","<files>",StringList(),"output files separated by blanks",true);
		setValidFormats_("out",StringList::create(formats));
		registerOutputFileList_("transformations","<files>",StringList(),"transformation output files separated by blanks",false);
		setValidFormats_("transformations", StringList::create("trafoXML"));
		registerStringOption_("type","<name>","","Map alignment algorithm type",true);
		setValidStrings_("type", getToolList()[toolName_()]);
		// TODO  Remove this hack when StringList becomes available in INIFileEditor. Transformations should be specified in algorithm section.
		registerInputFileList_("given_transformations","<files>",StringList(),"Transformations to apply by the 'apply_given_trafo' algorithm",false);
		setValidFormats_("given_transformations",StringList::create("trafoXML"));

		registerTOPPSubsection_("reference", "Options to define a reference file (currently only supported by the algorithms 'identification' and 'pose_clustering_affine')");
		registerInputFile_("reference:file", "<file>", "", "File to use as reference (for the 'pose_clustering_affine' algorithm, same file format as input files required)\n", false);
		setValidFormats_("reference:file", StringList::create(formats));
		registerIntOption_("reference:index", "<number>", 0, "Use one of the input files as reference ('1' for the first file, etc.)", false);
		setMinInt_("reference:index", 0);

    addEmptyLine_();
		addText_("This tool takes a number of input files, aligns them and writes the results to the output files.");

		registerSubsection_("algorithm","Algorithm parameters section");
	}

	Param getSubsectionDefaults_(const String& /* section */ ) const
	{
		String type = getStringOption_("type");
		MapAlignmentAlgorithm* algo = Factory<MapAlignmentAlgorithm>::create(type);
		Param tmp = algo->getParameters();

		// TODO  Remove this hack when StringList when become available in INIFileEditor.
		if (type == "apply_given_trafo")
		{
			tmp.setValue("transformations", getStringList_("given_transformations"));
		}

		delete algo;
		return tmp;
	}

	ExitCodes main_(int , const char**)
	{
		//-------------------------------------------------------------
		// parameter handling
		//-------------------------------------------------------------
		StringList ins = getStringList_("in");

		StringList outs = getStringList_("out");

		StringList trafos = getStringList_("transformations");

		String type = getStringOption_("type");

		ProgressLogger progresslogger;
		progresslogger.setLogType(log_type_);

		//-------------------------------------------------------------
		// check for valid input
		//-------------------------------------------------------------
		//check whether the number of input files equals the number of output files
		if (ins.size()!=outs.size())
		{
			writeLog_("Error: The number of input and output files has to be equal!");
			return ILLEGAL_PARAMETERS;
		}
		//check whether the number of input files equals the number of output files
		if (trafos.size()!=0 && ins.size()!=trafos.size())
		{
			writeLog_("Error: The number of input and transformation files has to be equal!");
			return ILLEGAL_PARAMETERS;
		}
		//check whether all input files have the same type (this type is used to store the output type too)
		FileTypes::Type in_type = FileHandler::getType(ins[0]);
		for (Size i=1;i<ins.size();++i)
		{
			if (FileHandler::getType(ins[i])!=in_type)
			{
				writeLog_("Error: All input files have to be in the same format!");
				return ILLEGAL_PARAMETERS;
			}
		}
		// check reference parameters:
		Size reference_index = getIntOption_("reference:index");
		String reference_file = getStringOption_("reference:file");
		if (reference_index && !reference_file.empty())
		{
			writeLog_("Error: 'reference:index' and 'reference:file' cannot be used together");
			return ILLEGAL_PARAMETERS;
		}
		if (reference_index > ins.size())
		{
			writeLog_("Error: 'reference:index' must not be higher than the number of input files");
			return ILLEGAL_PARAMETERS;
		}

    //-------------------------------------------------------------
    // set up alignment algorithm
    //-------------------------------------------------------------
    MapAlignmentAlgorithm* alignment = Factory<MapAlignmentAlgorithm>::create(type);
		Param alignment_param = getParam_().copy("algorithm:", true);

		// TODO  Remove this hack when StringList when become available in INIFileEditor.
		if (type == "apply_given_trafo")
		{
			alignment_param.setValue("transformations",getStringList_("given_transformations"));
		}

		writeDebug_("Used alignment parameters", alignment_param, 3);
		alignment->setParameters(alignment_param);
		alignment->setLogType(log_type_);

		// pass the reference parameters on to the algorithm:
		alignment->setReference(reference_index, reference_file);

		std::vector<TransformationDescription> transformations;

    //-------------------------------------------------------------
    // perform peak alignment
    //-------------------------------------------------------------
		if (in_type == FileTypes::MZML)
		{
			// load input
			std::vector< MSExperiment<> > peak_maps(ins.size());
			MzMLFile f;
			f.setLogType(log_type_);
			for (Size i=0; i<ins.size(); ++i)
			{
		    f.load(ins[i], peak_maps[i]);
			}

			// try to align
			try
			{
				alignment->alignPeakMaps(peak_maps,transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for peak data!");
				return INTERNAL_ERROR;
			}

			// write output
			progresslogger.startProgress(0,outs.size(),"writing output files");
			for (Size i=0; i<outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(peak_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], peak_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform feature alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::FEATUREXML)
		{
			// load input
			std::vector< FeatureMap<> > feat_maps(ins.size());
			FeatureXMLFile f;
			// f.setLogType(log_type_); // TODO
			progresslogger.startProgress(0,ins.size(),"loading input files");
			for (Size i=0; i<ins.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.load(ins[i], feat_maps[i]);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignFeatureMaps(feat_maps,transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for feature data!");
				return INTERNAL_ERROR;
			}

			// write output
			progresslogger.startProgress(0,outs.size(),"writing output files");
			for (Size i=0; i<outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(feat_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], feat_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform consensus alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::CONSENSUSXML)
		{
			// load input
			std::vector<ConsensusMap> cons_maps(ins.size());
			ConsensusXMLFile f;
			// f.setLogType(log_type_); // TODO
			progresslogger.startProgress(0,ins.size(),"loading input files");
			for (Size i=0; i<ins.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.load(ins[i], cons_maps[i]);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignConsensusMaps(cons_maps,transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for consensus feature data!");
				return INTERNAL_ERROR;
			}

			// write output
			progresslogger.startProgress(0,outs.size(),"writing output files");
			for (Size i=0; i<outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(cons_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], cons_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform peptide alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::IDXML)
		{
			// load input
			std::vector<  std::vector<ProteinIdentification> > protein_ids_vec(ins.size());
			std::vector<  std::vector<PeptideIdentification> > peptide_ids_vec(ins.size());

			IdXMLFile f;
			// f.setLogType_(log_type_);

			progresslogger.startProgress(0,ins.size(),"loading input files");
			for (Size i=0; i<ins.size(); ++i)
			{
				progresslogger.setProgress(i);
				String document_id;
		    f.load( ins[i], protein_ids_vec[i], peptide_ids_vec[i], document_id);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignPeptideIdentifications(peptide_ids_vec,transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for peptide data!");
				return INTERNAL_ERROR;
			}

			// write output
			progresslogger.startProgress(0,outs.size(),"writing output files");
			for (Size i=0; i<outs.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.store( outs[i], protein_ids_vec[i], peptide_ids_vec[i] );
			}
			progresslogger.endProgress();
		}
		else
		{
			// TODO can this really happen? I think it is tested above. Otherwise
			// throw an appropriate exception?
			return ILLEGAL_PARAMETERS;
		}

		delete alignment;

		if (trafos.size()!=0)
		{
			for (Size i=0; i<transformations.size(); ++i)
			{
				TransformationXMLFile().store(trafos[i],transformations[i]);
			}
		}

		return EXECUTION_OK;
	}
};


int main( int argc, const char** argv )
{
  TOPPMapAligner tool;
  return tool.main(argc,argv);
}

/// @endcond
