// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

/// @cond INTERNAL_INFO

/**

@page coding_conventions OpenMS Coding conventions

<CENTER>$Revision$</CENTER>

<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Formatting</H1>

All OpenMS files use a tab width of two. Use the command <TT>set tabstop=2</TT> in
<TT>vi</TT> or <TT>set-variable tab-width 2</TT> if you are using <TT>emacs</TT>. For
those two editors, the indentation behavior should be set automatically
throught the standard file headers (see below).
Due to these ugly issues with setting the tabwidth in the editor, it is
perfectly ok not to use tabs at all.  In emacs, you can replace all tabs with
the right number of spaces by typing the following keys: <TT>C-x h</TT> (to
mark the whole buffer), then <TT>M-x untabify RET</TT>.

All lines are terminated UNIX-type by a LF character.  If you have
accidentally inserted CRLF or CR line endings when edting on a Windows or Mac
system, you can fix that later on with the <code>dos2unix</code> command.  Using a
consistent style for line endings is important to make commands like
<code>svn praise</code> helpful.

Matching pairs of opening and closing curly braces should be set to the same
column:

@code
while (continue == true)
{
  for (int i = 0; i < 10; i++)
  {
    ...
  }

  if (x < 7)
  {
    ....
  }
}
@endcode
The main reason for this rule is to avoid constructions like:

@code
if (isValid(a))
  return 0;
@endcode

which might later be changed to something like

@code
if (isValid(a))
  error = 0;
  return 0;
@endcode

The resulting errors are hard to find. There are two ways to avoid these
problems: (a) always use braces around a block (b) write everyting in a single
line. We recommend method (a).
However, this is mainly a question of personal style, so no explicit checking
is performed to enforce this rule.

<H2 style="margin-top:20px; border-top:1px solid grey;">Sample .h file</H2>

@code
// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
... copyright header, not shown ...
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#ifndef OPENMS_CORE_DPEAK_H
#define OPENMS_CORE_DPEAK_H

#include <OpenMS/CONCEPT/Types.h>

#include <functional>
#include <sstream>

namespace OpenMS
{
   ... the actual code goes here ...
} // namespace OpenMS

#endif // OPENMS_CORE_DPEAK_H
@endcode
<H2 style="margin-top:20px; border-top:1px solid grey;">Sample .C file</H2>

@code
// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
... copyright header, not shown ...
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#include <OpenMS/CORE/DPeak.h>

namespace OpenMS
{
   ... the actual code goes here ...
} // namespace OpenMS
@endcode
Every <TT>.h</TT> file must be accompanied by a <TT>.C</TT> file, even if is
just a ``dummy''.  This way a global <TT>make</TT> will
stumble across errors.
<BR>
For template classes default instances with common template arguments should be put into 
the <tt>.C</tt> file. The varaible names of these instances start with <tt>default_</tt>. 
Here an example for the <tt>DPeak</tt> class:
@code
#include <OpenMS/KERNEL/DPeak.h>

namespace OpenMS
{
  /// @cond DOXYGEN_IGNORES_THIS
  DPeak<1> default_dpeak_1;
  DPeak<2> default_dpeak_2;
  /// @endcond
}
@endcode
The compiler does instanciate the template and detects errors at compile time that
way. Doing this saves your time! Otherwise the error is detected much laten, when 
the test is compiles.

<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Class requirements</H1>

Each OpenMS class has to provide the following minimal interface:
@code
class Test
{
  public:
    
    // default constructor (can be private in order to hide it)
    Test();

    // copy constructor
    Test(const Test& test);

    // destructor
    virtual ~Test();

    // assignment operator
    Test& operator = (const Test& test)
    {
      //ALWAYS CHECK FOR SELF ASSIGNEMT!
      if (this == &test) return *this;
      //...
      return *this;
    }
};
@endcode

Note that the destructor should be a virtual function, unless you have a very
good reason why it shouldn't.  (E.g., saving a vtable pointer.)  Essentially,
the reason is that otherwise an <TT>operator delete</TT> invocation on a
pointer to a base class will fail badly.




<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">General rules</H1>

<H2 style="margin-top:20px; border-top:1px solid grey;">Namespaces and the 'using' directive</H2>

The main OpenMS classes are implemented in the namespace <TT>OpenMS</TT>.
Auxilary classes are implemented in <TT>OpenMS::Internal</TT>.
There are some other namespaces e.g. for constants and exceptions.
<p>
For <TT>.h</TT> files it is strictly forbidden to use <TT>using namespace OpenMS;</TT>, 
<TT>using namespace std;</TT> or similar. This may cause name clashes (see 'Effective C++').
<p>
In <TT>.C</TT> files you should not import complete namespaces to the scope either.
Instead, introduce individual symbols to the scope where you need
them. E.g. you would write <TT>using std::vector;</TT> instead of <TT>using namespace std;</TT>.
This immediately gives a hint to where the symbol is defined as well.

<H2 style="margin-top:20px; border-top:1px solid grey;">Accessors to members</H2>

Accessors to protected or private members of a class are implemented as a pair
of get-method and set-method. This is necessary as accessors that return references to a member cannot be wrapped with Python!

For members that are too large to be read with the get-method, modified and written back with the set-method, 
an additional non-const get-method can be implemented!

@code
class Test
{
  public:
  	// always implement a non-mutable get-method
    Type& getMember() const
    {
      return member_;
    }
    
		// always implement a set-method
    void setName(const Type& name)
    {
      name_ = member_;
    }
		
		// if really necessary implement a mutable get-method
    Type& getName()
    {
      return member_;
    }

  protected:
    Type member_;
};
@endcode

<H2 style="margin-top:20px; border-top:1px solid grey;">Pass-by-value versus pass-by-reference</H2>
Except of primitive types all method arguments should be passed as non-mutable references.
<p>
Return types of methods should be non-mutable references as well.
Sometimes you cannot use references as the retuned value is constructed in the method.
If the constructed type is large, you can save computation time like that:
@code
//Bad idea
LargeObject someFunction()
{
  LargeObject tmp = ...
  return tmp;
}

//Better idea
void someFunction(LargeObject& obj)
{
  obj = ...
}
@endcode

<H2 style="margin-top:20px; border-top:1px solid grey;">Pointer or reference</H2>
If you do not have really good reasons to do so, do not use pointers.
They tend to cause segmentation faults!
In 9 out of 10 cases a reference does the job as well!

<H2 style="margin-top:20px; border-top:1px solid grey;">Iterators</H2>

In simple looping constructs, iterators are generally preferable to indexed
access.  Prefer ``<code>++i</code>'' to ``<code>i++</code>'', because the preincrement operator can safe
a copy constructor.  Use <code>const_iterators</code> where possible to help
avoiding unwanted side effects.


<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Exception handling</H1>

No OpenMS program should dump a core if an error occurs. Instead, it should
attempt to die as gracefully as possible. Furthermore, as OpenMS is a
framework rather than an application, it should give the programmer ways to
catch and correct errors.
The recommended procedure to handle - even fatal - errors is to throw an exception. Uncaught
exception will result in a call to <TT>abort</TT> thereby terminating the
program.

All exceptions used in OpenMS are derived from <TT>Exception::Base</TT>
defined in <TT>CONCEPT/Exception.h</TT>. A default constructor should not be
implemented for these exceptions. Instead, the constructor of all derived
exceptions should have the following signature:

@code
  AnyException(const char* file, int line, const char* function[, ...]);
@endcode
Additional arguments are possible but should provide default values (see
<TT>IndexOverflow</TT> for an example).

The <TT>throw</TT> directive for each exception should be of the form
@code
  throw AnyException(__FILE__, __LINE__, __PRETTY_FUNCTION__);
@endcode

to simplify debugging.  <TT>__FILE__</TT> and <TT>__LINE__</TT> are standard-defined
preprocessor macros.  The symbol <TT>__PRETTY_FUNCTION__</TT> works similar to a
<code>char*</code> and contains the type signature of the function as well as its
bare name, if the GNU compiler is being used.  It is defined to
<code>&lt;unknown&gt;</code> on other platforms. Exception::Base provides methods
(<TT>getFile</TT>, <TT>getLine</TT>, <TT>getFunction</TT>) that allow the localization
of the exception's cause.

<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Naming conventions</H1>

<H2 style="margin-top:20px; border-top:1px solid grey;">File names</H2>

Header files and source files should be named as the classes they
contain.
Source files end in ".C", while header files end in ".h". File names should be
capitalized exactly as the class they contain (see below). Each header/source
file should contain one class only, although exceptions are possible for
light-weight classes.
<H2 style="margin-top:20px; border-top:1px solid grey;">Underscores</H2>

Usage of underscores in names has two different meanings: A trailing ``_'' at
the end indicates that something is protected or private to a class.  Apart
from that, different parts of a name are sometimes separated by an underscore,
and sometimes separated by capital letters.  (The details are explained below.)

Note that according to the C++ standard, names that start with an underscore
are reserved for internal purposes of the language and its standard library
(roughly speaking), so you should never use them.
<H2 style="margin-top:20px; border-top:1px solid grey;">Class / type / namespace names</H2>
Class names and type names always start with a capital letter.
Different parts of the name are separated by capital letters at the beginning
of the word. No underscores are allowed in type names and class names, except
for the names of protected types and classes in classes, which are suffixed by
an underscore.  The same conventions apply for <TT>namespace</TT>s.

@code
class Simple; //ordinary class
class SimpleThing; //ordinary class
class PDBFile; //using an abbreviation
class Buffer_; //protected or private nested class
class ForwardIteratorTraits_; //protected or private nested class
@endcode


<H2 style="margin-top:20px; border-top:1px solid grey;">Variable names</H2>

Variable names are all lower case letters.  Distinguished parts of
the name are separated using underscores ``<TT>_</TT>''. If parts of the name
are derived from common acronyms (e.g. MS) they should be in upper case.
Private or protected member variables of classes are suffixed by an
underscore.

@code
int simple; //ordinary variable
bool is_found; //ordinary variable
string MS_instrument; //using an abbreviation
int counter_; //protected or private member
int persistent_id_; //protected or private member
@endcode

No prefixing or suffixing is allowed to identify the variable type - this
leads to completely illegible documentation and overly long variable names.
<H2 style="margin-top:20px; border-top:1px solid grey;">Function names/method names  </H2>

Function names (including class method names) always start with a
  lower case letter.  Parts of the name are separated using capital letters
(as are types and class names).  They should be comprehensible, but as short
as possible.  The same variable names must be used in the declaration and in
the definition.  Arguments that are actually not used in the implementation of
a function have to be commented out - this avoids compiler warnings.  The
argument of <TT>void</TT> functions (empty argument list) must omitted in both
the declaration and the definition.  If function arguments are pointers or
references, the pointer or reference qualifier is appended to the variable
type. It should not prefix the variable name.

@code
void hello(); //ordinary function, no arguments
int countPeaks(PeakArray const& p); //ordinary function
bool ignore(string& /* name */); //ordinary function with an unused argument
bool isAdjacentTo(Peak const * const * const & p) const; //an ordinary function
bool doSomething_(int i, string& name); //protected or private member function
@endcode
<H2 style="margin-top:20px; border-top:1px solid grey;">Enums and preprocessor constants</H2>

Enumerated values and preprocessor constants are all upper case
  letters.  Parts of the name are separated by underscores.

@code
#define MYCLASS_SUPPORTS_MIN_MAX 0 //preprocessor constant
enum DimensionId { DIM_MZ = 0, DIM_RT = 1 }; //enumerated values
enum DimensionId_ { MZ = 0, RT = 1 }; //enumerated values
@endcode

(You should avoid using the preprocessor anyway.  Normally, <TT>const</TT> and
<TT>enum</TT> will suffice unless something very special.)
<H2 style="margin-top:20px; border-top:1px solid grey;">Parameters</H2>

Parameters in .ini files and elsewhere are named like the things they
represent.  (By a parameter we mean the <I>keys</I> used in the <TT>Param</TT>
class.)  Typically this will be tool names, public member variables, or public class names
(e.g. in case of factories).

<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Documentation</H1>

<H2 style="margin-top:20px; border-top:1px solid grey;">UML diagrams</H2>

To generate UML diagrams use yEd and export the diagrams in png format. Do not
forget to save also the corresponding .yed file.
<H2 style="margin-top:20px; border-top:1px solid grey;">Doxygen  </H2>

Each OpenMS class has to be documented using Doxygen. The documentation is
inserted in Doxygen format in the header file where the class is
defined.  Documentation includes the description of the class, of each method,
type declaration, enum declaration, each constant, and each member variable.

Longer pieces of documentation start with a brief description, followed
by an empty line and a detailed description. The empty line is needed to separate
the brief from the detailed description.

Descriptions of classes always have a brief section!

Please use the doxygen style of the following example for OpenMS:
@verbatim
/**
  @defgroup DummyClasses Dummy classes

  @brief This class contains dummy classes

  Add classes by using the '@ingroup' command.
*/

/**
  @brief Demonstration class.

  A demonstration class for teaching doxygen

  @note All classes need brief description!

  @todo Write tests of this class! (Max Mustermann)

  @ingroup DummyClasses
*/

class Test
{
  public:
    /**
      @brief An enum type.

      The documentation block cannot be put after the enum!
    */
    enum EnumType
    {
      int EVal1,     ///< Enum value 1.
      int EVal2      ///< Enum value 2.
    };

    /**
      @brief constructor.

      A more elaborate description of the constructor.
    */
    Test();

    /**
      @brief Dummy function.

      A normal member taking two arguments and returning an integer value.
      The parameter @p dummy_a is an integer.
      @param dummy_a an integer argument.
      @param dummy_s a constant character pointer.
      @see Test()
      @return The dummy results.
    */
    int dummy(int dummy_a, const char *dummy_s);

    /// Brief description in one line.
    int isDummy();

    /**
      @name Group of members.

      Description of the group.
    */
    //@{
    /// Dummy 2.
    void dummy2();
    /// Dummy 3.
    void dummy3();
    //@}

  protected:
    int value;       ///< An integer value.
};
@endverbatim

The defgroup command indicates that a comment block contains documentation for a group of classes, files or namespaces.
This can be used to categorize classes, files or namespaces, and document those categories.
You can also use groups as members of other groups, thus building a hierarchy of groups.
Using the ingroup command a comment block of a class, file or namespace will be added to the group or groups.

The groups (or modules as doxygen calls them) definded by the ingroup command should contain only the classes 
of special interest to the OpenMS user. Helper classes and such must be omitted.

Documentation which does not belong to a specific .C or .h file can be written into a
separate Doxygen file (with the ending .doxygen). This file will also be parsed by Doxygen.

Open tasks are noted in the documentation of a header or a group using the todo command.
The ToDo list is then shown in the doxygen menu under 'Related pages'. Each ToDo should be
followed by a name in parentheses to indicated who is going to handle it.

Doxygen is not hard to learn, have a look at the manual :-)
<H2 style="margin-top:20px; border-top:1px solid grey;">Commenting code</H2>

The code for each .C file has to be commented. Each piece of code in OpenMS
has to contain at least 5% of comments. The use of @verbatim// Comment text@endverbatim instead of
C style comments @verbatim /* Comment text */ @endverbatim is recommended to avoid problems arising from
nested comments. Comments should be written in plain english and describe the functionality of the next few lines.

<H2 style="margin-top:20px; border-top:1px solid grey;">Examples</H2>

Instructive programming examples can be provided in the
<TT>source/EXAMPLES</TT> directory.

<H2 style="margin-top:20px; border-top:1px solid grey;">Revision control</H2>

OpenMS uses the Subversion to manage different
versions of the source files. For easier identification of the responsible person
each OpenMS file contains the <TT>$Maintainer:$</TT> string in the
preamble.

Examples of <TT>.h</TT> and <TT>.C</TT> files have been given above.  In
non-C++ files (Makefiles, (La)TeX-Files, etc.) the C++ comments are replaced
by the respective comment characters (e.g. ``#'' for Makefiles, ``%'' for
(La)TeX).  TeX will switch to math mode after a <TT>$</TT>, but you can work
around this by writing something like

<TT>Latest SVN $ $Date:$ $</TT>
if you want to use it in texts; the one here expands to
``Latest SVN Date: 2007-01-19 13:47:36 +0100 (Fri, 19 Jan 2007) ''. Subversion does not turn on keyword substitution by default.  See <TT>svn
  -h propset</TT> and <TT>svn -h proplist</TT> for details.

<H1 style="margin-top:40px; border-top:4px solid grey; text-align:left;">Testing</H1>

<H2 style="margin-top:20px; border-top:1px solid grey;">General</H2>

Each OpenMS class has to provide a test program. This test program has to check
each method of the class. The test programs reside in the directory
<TT>source/TEST</TT> are usually named <TT>&lt;classname&gt;_test.C</TT>. The test program has to be coded using the class test
macros as described in the OpenMS online reference. Special care should be taken
to cover all special cases (e.g. what happens, if a method is called with
empty strings, negative values, zero, null pointers etc.).
Please activate the keyword substitution of '$Id$' for all tests with the following command:
<TT>svn propset svn:keywords Id &lt;file&gt;</TT>.

<H2 style="margin-top:20px; border-top:1px solid grey;">Suplementary files</H2>

If a test needs suplementary files, put these files in the <TT>source/TEST/data/</TT> folder.
The name of suplementary files has to begin with the name of the tested class.

<H2 style="margin-top:20px; border-top:1px solid grey;">Structure of a test program</H2>

<H3>Macros to start, finish and evaluate tests</H3>

<UL>
	<LI><TT>START_TEST(class_name, version)</TT><BR> Start of a class test file (initialization)
	<LI><TT>END_TEST</TT><BR> End of a class test file (cleanup)
	<LI><TT>CHECK(name)</TT><BR> Start of a single test, e.g. for a method
	<LI><TT>RESULT</TT><BR> End of a single test
	<LI><TT>STATUS(message)</TT><BR> Shows a status message e.g. used to show the progress of a test preparations that take a while
	<LI><TT>ABORT_IF(condition)</TT><BR> Skip remainder of substest if condition holds
</UL>

<H3>Comparison macros</H3>

<UL>
	<LI><TT>TEST_EQUAL(a, b)</TT><BR> Tests if two expressions are equal
	<LI><TT>TEST_NOT_EQUAL(a, b)</TT><BR> Tests if two expressions are not equal
	<LI><TT>TEST_REAL_EQUAL(a, b)</TT><BR> Tests if two real numbers are equal (within a margin)
	<LI><TT>TEST_STRING_EQUAL(a, b)</TT><BR> Tests if <TT>a</TT> and <TT>b</TT> are equal as strings
	<LI><TT>PRECISION(double)</TT><BR> Sets the margin for TEST_REAL_EQUAL(a, b)
	<LI><TT>TEST_EXCEPTION(exception, expression)</TT><BR> Tests if the expression throws the exception
	<LI><TT>TEST_FILE(file, template_file)</TT><BR> Tests if two files are identical
</UL>

Do not use methods with side-effects inside the comparison macros i.e. *(it++). The expressions
in the macro are called serveral times, so the side-effect is triggered several times as well.

<H3>Temporary files</H3>

You might want to create temporary files during the tests. The following macro
puts a temporary filename into the string argument. The file is automatically deleted
after the test.

<UL>
  <LI><TT>NEW_TMP_FILE(string)</TT>
</UL>

<H3>Tools for testing and checking your code.</H3>

There are also some PHP tools for testing other tasks in the <TT>source/config/tools/</TT> directory.
See <TT>source/config/tools/README.txt</TT> for details!

<H2 style="margin-top:20px; border-top:1px solid grey;">Testing the TOPP programs</H2>

The abbreviation TOPP stands for The OpenMS

Proteomics Pipeline, a collection of tools based upon the
C++ classes in OpenMS.  The TOPP tools are located in <TT>source/APPLICATIONS/TOPP</TT>.

<H3>Suplementary files</H3>

If a test needs suplementary files, put these files in the same folder.
The name of suplementary files has to begin with the name of the tested tool.
All extensions but <TT>.tmp</TT>, <TT>.output</TT> or <TT>.log</TT> are possible.

<H3>Running the tests</H3>

The tests for TOPP programs are located in <TT>source/TEST/TOPP</TT>.
The <TT>Makefile</TT> provides the following main targets:

<UL>
<LI>make : Run all tests.  This invokes the <TT>default</TT> make target.
Each tool has its own make target, e.g. to test <TT>TOPPTool</TT>
  you can run <TT>make TOPPTool_test</TT>.  The test targets are listed in
  the variables <TT>TOPP_TOOL_TESTS</TT> (for each tool individually) and
  <TT>TOPP_PIPELINE_TESTS</TT> (for pipelines composed out of several
  tools).  Note that these sub-targets should be maintained by the same
maintainers as the tools themselves!

<LI>make debug : Run all tests in debug mode.


Each tool test will create a couple of <TT>.tmp</TT> files.  Normally, these
  are deleted automatically.  You can set <TT>DEBUG=1</TT> to avoid this.
  <TT>make debug</TT> is equivalent to <TT>make DEBUG=1 default</TT>.  You can
  run any test in debug mode, e.g.  <TT>make DEBUG=1 TOPPTool_test</TT>.


<LI>make verbose : Run all tests in verbose mode.

Normally, all output written to <TT>stdout</TT> and <TT>stderr</TT> by the
  tools is redirected to <TT>/dev/null</TT>.  You can set <TT>VERBOSE=1</TT>
  to avoid this.  <TT>make verbose</TT> is equivalent to <TT>make
    VERBOSE=1 default</TT>.  You can run any test in verbose mode, e.g.
  <TT>make VERBOSE=1 TOPPTool_test</TT>.


<LI>make clean : This target will remove all temporary files
  created by the tests.  You can use it to clean up after <TT>make debug</TT>
  or any other test.  In order to make this target effective, it is important
  that all files generated by your tests will (finally) have a suffix
  <TT>.tmp</TT>, <TT>.log</TT> (e.g. <TT>TOPP.log</TT>), or
  <TT>.rounded_tmp</TT> (explained below).  Of course you can rename them
  using <TT>$(MV)</TT> to achieve this.

</UL>


<H3> Macros for writing the tests</H3>

The actual tests are written using (1.) macros which are defined by
<TT>configure</TT> in <TT>config_defs.mak</TT> and (2.) some special
functions using substitution capabilities of the (GNU) make program itself.


<UL>
<LI>Don't write commands like <TT>echo</TT>, <TT>diff</TT>, <TT>mv</TT>,
  <TT>cp</TT>, <TT>rm</TT> directly - always use their 'uppercase'
  counterparts <TT>$(ECHO)</TT>, <TT>$(DIFF)</TT>, <TT>$(MV)</TT>,
  <TT>$(CP)</TT>, <TT>$(RM)</TT> provided by <TT>configure</TT>.  Doing so is
  necessary for portability.


<LI>To invoke a TOPP tool with options, use the following syntax:

<TT>@$(call RUN_PROG_OPT,TOPPTool,options)</TT>

Be careful not to insert any whitespace around the arguments of
  <TT>call</TT>.  Depending on the <TT>VERBOSE</TT> settings, this macro is
  expanded in different ways by <TT>make</TT> program.


<LI>To check whether the output of a TOPP tool is correct, use the following syntax:

<TT>@$(call TEST_FILE_EQUAL,correct.xtn)</TT>

or

<TT>@$(call TEST_FILE_EQUAL,correct.xtn,computed.tmp)</TT>

This will compare two files using a small diff-like application called
  <TT>NumericDiff</TT> (explained in the next section).  In the first form,
  the 'other' file defaults to <TT>correct.tmp</TT>, that is, the basename of
  the second argument (<TT>correct.xtn</TT>) extended by <TT>.tmp</TT>.  Be
  careful not to insert any whitespace around the arguments of <TT>call</TT>.
  Depending on the <TT>DEBUG</TT> settings, this macro is expanded in
  different ways by <TT>make</TT> program.


</UL>


<H3>Numerical inaccuracy</H3>

The TOPP tests will be run on 32 bit and 64 bit platforms.  Therefore a purely
character-based comparison of computed and expected result files might fail
although the results are in fact numerically correct - think of cases like
<TT>9.999e+3</TT> vs. <TT>1.0001e+4</TT>.  Instead we provide a small program

<TT>NumericDiff</TT> in <TT>source/TEST/TOPP</TT>.  This program steps
through both inputs simultaneously and classifies each position into 3
categories: <I>numbers</I>, <I>characters</I>, <I>whitespace</I>.  Within each
line of input, numbers are compared with respect to their ratio (i.e.,
relative error), characters must match exactly (e.g. case is significant) and
all whitespace is considered equal.  Empty lines or lines containing only
whitespace are skipped, but extra linebreaks 'within' lines will result in error
messages.  For more details and verbosity options, see the built-in help
message and the source code.


<H3>File name conventions for TOPP tests</H3>

Each test relies on a number of files.  These file should be named 
<code>source/TEST/TOPP/&lt;toolname&gt;_&lt;nummer&gt;_&lt;name&gt;.&lt;extension&gt;</code>, where

<UL>
  <LI><code>&lt;toolname&gt;</code> has the form <code>[A-Z][a-zA-Z]*</code> -- the name of the TOPP tool
  <LI><code>&lt;number&gt;</code> has the form <code>[0-9]+</code> -- the running number of the test
  <LI><code>&lt;name&gt;</code> has the form <code>[-_a-zA-Z0-9]+</code> -- should be a
    descriptive name (<code>_</code> and <code>-</code> are ok here, since <code>&lt;toolname&gt;</code>
    and <code>&lt;number&gt;</code> must not contain them)
  <LI><code>&lt;extension&gt;</code> -- the extension expressing the type of the data.
</UL>
The data files should be as small as possible, but not totally trivial.


<H2 style="margin-top:20px; border-top:1px solid grey;">Is testing really necessary?</H2>

Yes. Testing is crucial to verify the correctness of the library - especially when
using C++. But why has it to be <EM>so</EM> complicated, using all these macros
and stuff? One of the biggest problems when building large class frameworks is
portability. C++ compilers are strange beasts and there is not a single one
that accepts the same code as any other compiler. Since one of the main
concerns of OpenMS is portability, we have to ensure that every single line of
code compiles on all platforms. Due to the long compilation times and the
(hopefully in future) large number of different platforms, tests to verify the
correct behaviour of all classes have to be carried out automatically. This
implies a well defined interface for all tests, which is the reason for all
these strange macros. This fixed format also enforces the writing of complete
class tests. Usually a programmer writes a few lines of code to test the parts
of the code he wrote for correctness. Of the methods tested after the
introduction of the test macros, about a tenth of all functions/methods showed
severe errors or after thorough testing. Most of these errors didn't occur an
all platforms or didn't show up on trivial input.

Writing tests for <EM>each</EM> method of a class also ensures that each line is
compiled. When using class templates the compiler only compiles the methods
called. Thus it is possible that a code segment contains syntactical errors
but the compiler accepts the code happily - he simply ignores most of the
code. This is quickly discovered in a complete test of all methods. The same
is true for configuration dependend preprocessor directives that stem from
platform dependencies. Often untested code also hides inside the <TT>const</TT>
version of a method, when there is a non-const method with the same name and
arguments (for example most of the <TT>getName</TT>) methods in OpenMS. In most
cases, the non-const version is preferred by the compiler and it is usually
not clear to the user which version is taken. Again, explicit testing of each
single method provides help for this problem.
The ideal method to tackle the problem of untested code is the complete
coverage analysis of a class. Unfortunately this is only supported for very
few compilers, so it is not used for testing OpenMS.


One last point: writing the
test program is a wonderful opportunity to verify and complete the
documentation! Often enough implementation details are not clear at the time
the documentation is written. A lot of side effects or special cases that were
added later do not appear in the documentation. Going through the
documentation and the implementation in parallel is the best way to verify the
documentation for consistence and (strange coincidence?!) the best way to
implement a test program, too!

*/

/// @endcond