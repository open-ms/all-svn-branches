// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

//########################### Please read this carefully! ###########################

// Sections:
// - prefix the tutorial pages with 'TOPP_'
// - to add new pages you have to add them to:
//    - doc/OpenMS_tutorial/refman_overwrite.tex (pdf output)
//    - doc/doxygen/public/OpenMS_Tutorial_html.doxygen (html output)

// Conventions:
// - Please write a short introduction for each chapter that explains
//   what classes are described and where these classes can be found (folder)
// - Use @a to visually highlight class names, namespaces, etc
// - When using example code, put it in the OpenMS/source/Examples folder
//   to make sure it can be compiled. The name of the file should be in the text
//   to make the file easy to find for the user.
//   Dont forget to add the built example application to the svn ignore list:
//   'svn propedit svn:ignore source/EXAMPLES/'
// - When talking about OpenMS in general, prefix it with a '%'. Otherwise a
//   link to the OpenMS namspace is generated automatically

//####################################### TERMS #######################################

/**

@page tutorial_ms_terms Mass spectrometry terms

 The following terms for MS-related data are used in this tutorial and the %OpenMS class documentation:
 - <b>raw data point</b> @n
   An unprocessed data point as measured by the instrument.
 - <b>peak</b> @n
   Data point that is the result of some kind of peak detection algorithm.
   Peaks are often referred to as @a sticks or @a centroided @a data as well.
 - <b>spectrum / scan</b> @n
   A mass spectrum containing raw data points (@a raw @a spectrum) or peaks (@a peak @a spectrum).

  @image html Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)"
  @image latex Terms_Spectrum.png "Part of a raw spectrum (blue) with three peaks (red)" width=10cm

 - <b>map</b> @n
   A collection of spectra generated by a HPLC-MS experiment. Depending on what kind of
   spectra are contained, we use the terms  @a raw @a map or @a peak @a map. Often a
   map is also referred to as an @a experiment.
 - <b>feature</b> @n
   The signal caused by a chemical entity detected in an HPLC-MS experiment, typically a peptide.

  @image html Terms_Map.png "Peak map with a marked feature (red)"
  @image latex Terms_Map.png "Peak map with a marked feature (red)" width=10cm

*/

//####################################### CONCEPT #######################################

/**

@page tutorial_concept OpenMS concepts

  This chapter covers some very basic concepts needed to understand %OpenMS code.
  It describes %OpenMS primitive types, namespaces, exceptions and
  important preprocessor macros. The classes described in this section can be found in the @a CONCEPT folder.

@section concept_primitives Basic data types

  %OpenMS has its own names for the C++ primitive types. The integer types of %OpenMS
  are @a Int (int) and @a UInt (unsigned int). For floating point numbers @a Real (float) and
  @a DoubleReal (double) are used.

  These and more types are defined in @a OpenMS/CONCEPT/Types.h.

@section concept_namespace The OpenMS namespace

  The main classes of %OpenMS are implemented in the namespace @a OpenMS. There are several
  sub-namespaces to the @a OpenMS namespace. The most important ones are:
  - @a OpenMS::Constants contains nature constants.
  - @a OpenMS::Math contains math functions and classes.
  - @a OpenMS::Exception contains the %OpenMS exceptions.
  - @a OpenMS::Internal contains certain auxiliary classes that are typically used by only one class of the @a OpenMS namespace and not by the user directly.

  There are several more namespaces. For a detailed description have a look at the
  class documentation.

@section concept_exceptions Exception handling in OpenMS

  All exceptions are defined in the namespace @a OpenMS::Exception. The Base class for all
  %OpenMS exceptions is @a Base.  This base class provides three members for storing
  the source file, the line number and the function name where the exception occurred.
  All derived exceptions provide a constructor that takes
  at least these arguments. The following code snippet shows the handling of an index overflow:
  @code
    void someMethod(UInt index) throw (Exception::IndexOverflow)
    {
      if (index >= size())
      {
        throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, index, size()-1);
      }
      // do something
    };
  @endcode
	Note the first three arguments given to the constructor:  @a __FILE__ and @a __LINE__ are
	built-in preprocessor macros that hold the file name and the line number.
  @a __PRETTY_FUNCTION__ is replaced by the GNU g++ compiler with the demangled name of
  the current function (including the class name and argument types).
  For other compilers it is defined as "<unknown>". For an index overflow exception,
  there are two further arguments: the invalid index and the maximum allowed index.

  The file name, line number and function name are very useful when debugging. However, %OpenMS
  also implements its own exception handler which allows to turn each uncaught exception into a
  segmentation fault. This mechanism allows developers to trace the source of an exception
  with a debugger. To use this feature, set the environment variable
  @a OPENMS_DUMP_CORE.

@section concept_macros Condition macros

  In order to enforce algorithmic invariants, the two preprocessor macros @a OPENMS_PRECONDITION and
  @a OPENMS_POSTCONDITION are provided. These macros are enabled only if debug info is enabled
  and optimization is disabled in @a configure. Otherwise they are removed by the preprocessor,
  so they won't cost any performance.

  The macros throw Exception::Precondition or Exception::Postcondition respectively if
  the condition fails. The example from section @ref concept_exceptions could have been
  implemented like that:
  @code
    void someMethod(UInt index)
    {
      OPENMS_PRECONDITION(index < size(),"Precondition not met!");
      //do something
    };
  @endcode

*/

//####################################### DATASTRUCTURES #######################################

/**

@page tutorial_datastructures Auxiliary datastructures

  This section contains a short introduction to three datastructures you will
  definitely need when programming with %OpenMS. The datastructures module of the
  class documentation contains many more classes, which are not mentioned here in
  detail. The classes described in this section can be found in the @a DATASTRUCTURES folder.

@section datastructures_string The OpenMS string implementation

  The %OpenMS string implementation @a String is based on the STL @a std::string.
  In order to make the %OpenMS string class more convenient, a lot of methods have been
  implemented in addition to the methods provided by the base class.
  A selection of the added functionaliy is given here:
  - Checking for a substring (suffix, prefix, substring, char)
  - Extracting a substring (suffix, prefix, substring)
  - Trimming (left, right, both sides)
  - Concatenation of string and other primitive types with @a operator+
  - Construction from QString and conversion to QString

@section datastructures_dposition D-dimensional coordinates

  Many %OpenMS classes, especially the kernel classes, need to store some kind of
  d-dimensional coordinates. The template class @a DPosition is used for that purpose.
  The interface of DPosition is pretty straightforward. The operator[] is used to
  access the coordinate of the different dimensions. The dimensionality is stored
  in the enum value @a DIMENSION. The following example (Tutorial_DPosition.C)
  shows how to print a DPosition to the standard output stream.

  First we need to include the header file for @a DPosition and @a iostream. Then we
  import all the %OpenMS symbols to the scope with the @a using directive.
  @dontinclude Tutorial_DPosition.C
  @until namespace
  The first commands in the main method initialize a 2-dimensional @a DPosition :
  @until 47.11
  Finally we print the content of the DPosition to the standard output stream:
  @until main

  The output of our first little %OpenMS program is the following:
  @code
    Dimension 0: 8.15
    Dimension 1: 47.11
  @endcode

@section datastructures_drange D-dimensional ranges

  Another important datastructure we need to look at in detail is @a DRange.
  It defines a d-dimensional, half-open interval through its two @a DPosition members.
  These members are accessed by the @a min and @a max methods and can be
  set by the @a setMin and @a setMax methods.

  DRange maintains the invariant that @a min is geometrically less or equal to @a max,
  i.e. @f$ \min()[x] \le \max()[x]@f$ for each dimension @a x. The following example (Tutorial_DRange.C) demonstrates this behavior.

  This time we skip everything before the main method. In the main method we
  create a range and assign values to @a min and @a max. Note that the the minimum
  value of the first dimension is larger than the maximum value.
  @dontinclude Tutorial_DRange.C
  @skip main
  @until setMax
  Then we print the content of @a range :
  @until main

  The output is:
  @code
    min 0: 1
    max 0: 1
    min 1: 3
    max 1: 5
  @endcode
  As you can see, the minimum value of dimension one was adjusted in order
  to make the maximum of @a 1 conform with the invariant.

  @a DIntervalBase is the closed interval counterpart (and base class) of @a DRange.
  Another class derived from @a DIntervalBase is @a DBoundingBox. It also represents a
  closed interval, but differs in the methods. Please have a look at the class
  documentation for details.

*/

//####################################### KERNEL #######################################

/**

@page tutorial_kernel The kernel classes

 The %OpenMS kernel contains the datastructures that store the actual MS data, i.e.
 raw data points, peaks, features, spectra, maps.
 The classes described in this section can be found in the @a KERNEL folder.

@section kernel_datapoints Raw data point, Peak, Feature, ...

  In general there are three types of data points: raw data points, peaks and picked peaks.
  Raw data points provide members to store position (mass-to-charge ratio, retention time, ...) and intensity.
  Peaks are derived from raw data points and add an interface to store meta information.
  Picked peaks are derived from peaks and have additional members for peak shape information:
  charge, width, signal-to-noise ratio and many more.

  The kernel data points exist in three versions: one-dimensional, two-dimensional and d-dimensional.

  @image html Kernel_DataPoints.png "Data structures for MS data points"
  @image latex Kernel_DataPoints.png "Data structures for MS data points" width=14cm

  @par one-dimensional data points
  The one-dimensional data points are most important, the two-dimensional and d-dimensional data points
  are needed rarely.
  The base class of the one-dimensional data points is @a RawDataPoint1D. It provides
  members to store the mass-to-charge ratio (@a getMZ and @a setMZ) and the intensity
  (@a getIntensity and @a setIntensity). @n
  @a Peak1D is derived from @a RawDataPoint1D and adds a interface for metadata (see @ref metadata_metainfo). @n
  @a PickedPeak1D is derived from @a Peak1D and adds information about the peak shape.

  @par two-dimensional data points
  The two-dimensional data points are needed when geometry algorithms are applied
  to the data points. A special case is the @a Feature class, which needs a two-dimensional
  position (m/z and RT). @n
  The base class of the two-dimensional data points is @a RawDataPoint2D. It provides
  the same interface as @a RawDataPoint1D and additional members for the retention time (@a getRT and @a setRT). @n
  @a Peak2D is derived from @a RawDataPoint2D and adds a interface for metadata. @n
  @a Feature is derived from @a Peak2D and adds information about the convex hull of the feature, fitting quality
  and so on.

  @par d-dimensional data points
  The d-dimensional data points are needed only in special cases, e.g. in template classes that
  must operate on any number of dimensions. @n
  The base class of the d-dimensional data points is @a DRawDataPoint. The methods to access the position
  are @a getPosition and @a setPosition. @n
  Note that the one-dimensional and two-dimensional data points also have the methods
  @a getPosition and @a setPosition. They are needed to able to write algorithms that can operate on
  all data point types. It is however recommended not to use these members unless you really write such
  a generic algorithm.

@section kernel_spectra Spectra

  @par one-dimensional spectrum
  The most important container for raw data and peaks is @a MSSpectrum. It is a template
  class that takes the peak type as template argument. The default peak type is @a Peak1D. Possible other peak types
  are classes derived from @a RawDataPoint1D or classes providing the same interface. @n
  @a MSSpectrum is derived from two base classes: @a DSpectrum, a generic container for d-dimensional peak data, and from
  @a SpectrumSettings, a container for the meta data of a spectrum. Here only MS data handling is explained,
  @a SpectrumSettings is described in section @ref metadata_spectrum.

  @par d-dimensional spectrum
  The base class of @a MSSpectrum is @a DSpectrum. This class provides a generic container for d-dimensional data.
  One of the template arguments of @a DSpectrum is the Container the data is stored in. As container @p DPeakArray or a
  container with the same interface is used. @a DPeakArray is vector of data points with a more convenient interface
  for sorting the data. @n
  The peak container can be accessed through the @a getContainer() method. For convenience, part of the container interface is
  also provided by @a DSpectrum.

  In the following example (Tutorial_MSSpectrum.C) program, a @a MSSpectrum is filled with peaks, sorted according to mass-to-charge
  ratio and a selection of peak positions is displayed.

  First we create a spectrum and insert peaks with descending mass-to-charge ratios:
  @dontinclude Tutorial_MSSpectrum.C
  @skip main
  @until }
  Then we sort the peaks according to ascending mass-to-charge ratio. As the method used for sorting is not wrapped by
  @a DSpectrum, we need to access the container to sort it.
  @until sort
  Finally we print the peak positions of those peaks between 800 and 1000 Thomson. For printing all the peaks in the
  spectrum, we simply would have used the STL-conform methods @a begin() and @a end().
  @until main

  @par Typedefs
  For convenience the following type definitions are defined in @a OpenMS/KERNEL/StandardTypes.h.
  @code
  typedef MSSpectrum<Peak1D> PeakSpectrum;
  typedef MSSpectrum<RawDataPoint1D> RawSpectrum;
  @endcode

@section kernel_maps Maps

  Although raw data maps, peak maps and feature maps are conceptually very similar. They are stored in different
  data types. For raw data and peak maps, the default container is @a MSExperiment, which is an array of @a MSSpectrum
  instances. Just as @a MSSpectrum it is a template class with the peak type as template parameter.

  In contrast to raw data and peak maps, feature maps are no collection of one-dimensional spectra, but an array
  of two-dimensional @a Feature instances. The main datastructure for feature maps is called @a FeatureMap.

  Although @a MSExperiment and @a FeatureMap differ in the data they store, they also have things in common.
  Both stores meta data that is valid for the whole map, i.e. sample description and instrument description.
  This data is stored in the common base class @a ExperimentalSettings.

  @par MSExperiment
  The following figure shows the big picture of the kernel datastructures. @a MSExperiment is
  derived from @a ExperimentalSettings (meta data of the experiment) and from @a vector<MSSpectrum>.
  The one-dimensional spectrum @a MSSpectrum is derived from SpectrumSettings (meta data of a spectrum)
  and from @a DSpectrum<1>, which stores the actual peak data in a @a DPeakArray. @n
  Since DPeakArray is can store all types of peaks derived from @a RawDataPoint, all the data containers
  are template classes, that take the peak type as template argument. This is omitted in the diagram for
  simplicity.

  @image html Kernel.png "Overview of the main kernel datastructures"
  @image latex Kernel.png "Overview of the main kernel datastructures" width=6cm

  @par Typedefs
  For convenience the following map types are defined in @a OpenMS/KERNEL/StandardTypes.h.
  @code
  typedef MSExperiment<Peak1D> PeakMap;
  typedef MSExperiment<RawDataPoint1D> RawMap;
  @endcode

  The following example program (Tutorial_MSExperiment.C), creates a @a MSExperiment containing four @a MSSpectrum instances.
  Then it iterates over an area and prints the peak positions in the area:

  First we create the spectra in a for-loop and set the retention time and MS level. Survey scans have
  a MS level of 1, MS/MS scans would have a MS level of 2, and so on.
  @dontinclude Tutorial_MSExperiment.C
  @skip main
  @until setMSLevel
  Then we fill each spectrum with several peaks. As all spectra would have the same peaks otherwise,
  we add the retention time to the mass-to-charge ratio of each peak.
  @until creation
  Finally we iterate over the RT range (2,3) and the m/z range (603,802) and print the peak positions.
  @until }
  The output of this loop is:
  @code
  2 - 702
  2 - 802
  3 - 603
  3 - 703
  @endcode
  For printing all the peaks in the experiment, we could have used the STL-iterators of the
  experiment to iterate over the spectra and the STL-iterators of the spectra to iterate over the peaks:
  @until main

  @par FeatureMap
  @a FeatureMap, the container for features, is simply a @a vector<Feature>. Additionally, it is
  derived from @a ExperimentalSettings, to store the meta information. Just like @a MSExperiment
  it is a template class. It takes the feature type as template argument.

  The following example (Tutorial_FeatureMap.C) shows how to insert two features into a map and iterate over the features.
  @dontinclude Tutorial_FeatureMap.C
  @skip main
  @until end of main

  @par RangeManager
  All peak and feature containers (@a DSpectrum, @a MSExperiment, @a FeatureMap) are also derived from @a RangeManager.
  This class facilitates the handling of MS data ranges. It allows to calculate and store both the position range
  and the intensity range of the container.

  The following example (Tutorial_RangeManager.C) shows the functionality of the class @a RangeManger using a @a FeatureMap.
  First a @a FeatureMap with two features is created, then the ranges are calulated and printed:
  @dontinclude Tutorial_RangeManager.C
  @skip main
  @until end of main

  The output of this program is:
  @code
  Int: 461.3 - 12213.5
  RT:  15 - 23.3
  m/z: 571.3 - 1311.3
  @endcode

*/

//####################################### METADATA #######################################

/**

@page tutorial_metadata How meta data is stored

  The meta information about an HPLC-MS experiment are stored in @a ExperimentalSettings and
  @a SpectrumSettings. All information that is not covered by these classes can be stored
  in the type-name-value datastructure @a MetaInfo. All classes described in this section
  can be found in the @a METADATA folder.

@section metadata_metainfo MetaInfo

  @a DataValue is a data structure that can store any numerical
  or string information. It also supports casting of the stored
  value back to its original type.

  @a MetaInfo is used to easily store information of any type, that does not fit into the the other
  classes. It implements type-name-value triplets.
  The main datastructure is an associative container that stores
  @a DataValue instances as values associated to string keys.
  Internally a the string keys are converted to integer keys for
  performance resaons i.e. a @a map<UInt,DataValue> is used.

  The @a MetaInfoRegistry associates the string keys used in
  @a MetaValue with the integer values that are used for
  internal storage. Each key used has to be registered at the
  registry first. The @a MetaInfoRegistry is a singleton.

  If you want a class to have a @a MetaInfo member, simply derive it from @a MetaInfoInterface.
  This class provides a @a MetaInfo member and the interface to access it.

  @image html MetaInfo.png "The classes involved in meta information storage"
  @image latex MetaInfo.png "The classes involved in meta information storage" width=5cm

  The following example (Tutorial_MetaInfo.C) shows how to use @a Metadata.
  First we must register the names we want to use, then we can set the values:
  @dontinclude Tutorial_MetaInfo.C
  @skip main
  @until Unique identifier
  In order to access the values we can either use the registered name or the index of the name.
  The @a getMetaValue method returns a @a DataValue, which has to be casted to the right type.
  If you do not know the type, you can use the @a DataValue::valueType() method.
  @until end of main

@section metadata_experiment Meta data of a map

  This class holds meta information about the experiment that is valid for the whole experiment:
  - protein identifications
  - preprocessing performed on the data
  - MS instrument
  - source file
  - contact person
  - sample description
  - instrument software
  - HPLC settings

  @image html ExperimentalSettings.png "Map meta information"
  @image latex ExperimentalSettings.png "Map meta information" width=10cm

@section metadata_spectrum Meta data of a spectrum

  This class contains meta information about settings specific to one spectrum:
  - spectrum-specific instrument settings
  - peptide and protein identifications
  - precursor information (of MS/MS spectra)
  - description of the @a MetaInfo present for each data point
  - information on the acquisition

  @image html SpectrumSettings.png "Spectrum meta information"
  @image latex SpectrumSettings.png "Spectrum meta information" width=7cm

*/

//####################################### FORMAT #######################################

/**

@page tutorial_format File and DB access

  All classes for file and database IO can be found in the @a FORMAT folder.

@section format_file File adapter classes

  The interface of most file adapter classes is very similar. They implement
  a @a load and a @a store method, that take a file name and the appropriate
  data structure.

  The following example (Tutorial_FileIO.C) demonstrates the use of @a MzDataFile
  and @a MzXMLFile to convert one format into another using @a MSExperiment to hold the temporary data:
  @dontinclude Tutorial_FileIO.C
  @skip main
  @until end of main

  @par FileHandler
  In order to make the handling of different file types easier, the class
  @a FileHandler can be used. It loads a file into the appropriate
  datastructure independent of the file type. The file type is determined
  from the file extention or the file contents:
  @code
  MSExperiment<> in;
  FileHandler handler();
  handler.loadExperiment("input.mzData",in);
  @endcode

@section format_db DB access

  For database access, the class @a DBAdapter is used. As its interface is very similar
  to the interface of the file adapters, so no example is shown here.

@section format_options PeakFileOptions

  In order to have more control over loading data from files or databases,
  most adapters can be configured using @a PeakFileOptions. The following options
  are available:
  - only a specific retention time range is loaded
  - only a specific mass-to.charge ratio range is loaded
  - only a specific intensity range is loaded
  - only spectra with a given MS level are loaded
  - only meta data of the whole experiment is loaded (@a ExperimentalSettings)

@section format_param Param

  Most algorithms of %OpenMS and some of the TOPP tools have many parameters. The parameters
  are stored in instances of @a Param. This class is similar to a Windows INI files.
  The actual parameters (type, name and value) are stored in sections. Sections can contain parameters
  and sub-sections, which leads to a tree-like structure. The values are stored in @a DataValue, but
  @a Param supports only the types @a string, @a int and @a float. @n
  Parameter names are given as a string including the sections and subsections in which ':' is used as a delimiter.

  The following example (Tutorial_Param.C) shows how a file description is given.
  @dontinclude Tutorial_Param.C
  @skip main
  @until end of main
*/

//####################################### TRANSFORMATION #######################################

/**

@page tutorial_transformations Data reduction

Data reduction in LC-MS analysis mostly consists of two steps. In the first step,
called "peak picking", important information of the mass spectrometric peaks
(e.g. peaks' mass centroid positions, their areas under curve and full-width-at-half-maxima)
 are extracted from the raw LC-MS data.
The second data reduction step, called "feature finding", represents the quantification of all peptides in a proteomic sample.
Therefore the signals in a LC-MS map caused by all charge and isotopic variants of the peptide are detected and summarized resulting
in  list of compounds or features, each characterized by mass, retention time and abundance.
The classes described in this section can be found in the @a TRANSFORMATIONS folder.

@image html RawPeakFeatureMap.png "Part of an LC-MS map at different stages of data reduction. Axes depict retention time, m/z, and intensity. From left to right raw data points, peak  picked data points and a feature are shown."
@image latex RawPeakFeatureMap.png "Part of an LC-MS map at different stages of data reduction. Axes depict retention time, m/z, and intensity. From left to right raw data points, peak picked data points and a feature are shown." width=10cm


@section transformations_pp Peak picking

For peak picking the class @a PeakPickerCWT is used. Because this class detects and
extracts mass spectrometric peaks it is applicable to LC-MS as well as MALDI raw data.

The following example (Tutorial_PeakPickerCWT.C)shows how to open a raw map (in mzData format), initialize a
 PeakPickerCWT object, set the most important parameters (the scale of the wavelet,
 a peak's minimal height and fwhm), and start the peak picking process.

@dontinclude Tutorial_PeakPickerCWT.C
  @skip main
  @until end of main

The output of the program is:
 @code
		Scale of the wavelet: 0.2
		Minimal fwhm of a mass spectrometric peak: 0.1
		Minimal intensity of a mass spectrometric peak 500

		Number of picked peaks 14
@endcode

@Note A rough standard value for the peak's scale is the average fwhm of a mass
spectrometric peak.



@section transformations_ff Peptide Quantification

The FeatureFinder implements an algorithms for the detection and
quantification of peptides from LC-MS maps. In constrast to the
previous step (peak picking) we do not only search for pronounced
signals (peak) in the LC-MS map but search explicitly for peptides
which can be recognized by their isotopic pattern.

OpenMS offers differnent algorithms for this task.

Writing an FeatureFinder application of your own is straightforward to do.
A short example (Tutorial_FeatureFinder.C) is given below. First we need to instantiate the FeatureFinder,
its parameters and the input/output data:

@dontinclude Tutorial_FeatureFinder.C
  @skip FeatureFinder ff;
  @until output

Then we run the FeatureFinder. The first argument is the algorithm name (here 'simple').
Using the second and third parameter the peak and feature data is handed to the algorithm.
The forth argument sets the parameters used by the algorithm.
  @until ff.run(
Now the FeatureMap is filled with the found features.

*/

//####################################### FILTERING #######################################

/**

@page tutorial_filtering Signal processing
%OpenMS offers several filters for the reduction of noise and baseline which disturb LC-MS measurements.
These filters work spectra-wise and can therefore be applied to a whole raw data map as well as
to a single raw spectrum. All filters offer functions for the filtering of raw data containers
(e.g. @a RawSpectrum) "filter" as well as functions for the processing of a collection of raw data
containers (e.g. @a RawMap) "filterExperiment".
The functions "filter" and "filterExperiment" can both be invoked with an input container along with an output
container or with iterators that define a range on the input container along with an output container.
The classes described in this section can be found in the @a FILTERING folder.

@section filtering_baseline Baseline filters
Baseline reduction can be perfomed by the @a TopHatFilter. The top-hat filter is a morphological filter
which uses the basic morphological operations "erosion" and "dilatation" to remove the baseline in raw data.
Because both operations are implemented as described by Van Herk the top-hat filter expects equally spaced raw
data points. If your data are not uniform yet, please use the @a LinearResampler to generate equally spaced data.

The @a TopHatFilter removes signal structures in the raw data which are broader than the size of the structuring element.

The following example (Tutorial_TopHatFilter.C) shows how to instantiate a tophat filter, set the lenth of the
structuring element and remove the base line in a raw LC-MS map.

@dontinclude Tutorial_TopHatFilter.C
  @skip main
  @until end of main

@note To remove the baseline the width of the structuring element should be greater than the width of a peak.


@section filtering_smoothing Smoothing filters

We offer two smoothing filters to reduce noise in LC-MS measurements.

@subsection filtering_smoothing_gaussian Gaussian filter

The class @a GaussFilter is a gaussian filter. The wider the kernel width the smoother the signal (the more detail
information get lost).

We show in the following example (Tutorial_GaussFilter.C) how to smooth a raw data map.
The gaussian kernel width is set to 1 m/z.

@dontinclude Tutorial_GaussFilter.C
  @skip main
  @until end of main


@note Use a gaussian filter kernel which has approximately the same width as your mass peaks.

@subsection filtering_smoothing_sgolay Savitzky Golay filter

The Savitzky Golay filter is implemented in two ways @a SavitzkyGolaySVDFilter and @a SavitzkyGolayQRFilter.
Both filters come to the same result but in most cases the @a SavitzkyGolaySVDFilter has a better run time.
The Savitzky Golay filters work only on equally spaced data. If your data are not uniform use the @a LinearResampler
to generate equally spaced data. The smoothing degree depends on two parameters, the frame size and the order
of the polynomial used for smoothing. The frame size corresponds to the number of filter coefficients,
so the width of the smoothing intervall is given by frame_size*spacing of the raw data.
The bigger the frame size or the smaller the order the smoother the signal (the more detail information get lost!).

The following example (Tutorial_SavitzkyGolayFilter.C) shows how to use a @a SavitzkyGolaySVDFilter (the @a SavitzkyGolayQRFilter has the same interface)
to smooth a single spectrum. The single raw data spectrum is loaded and resampled to uniform data with a spacing of 0.01 /m/z.
The frame size of the Savitzky Golay filter is set to 21 data points and the polynomial order is set to 3.
Afterwards the is applied to the resampled spectrum.

@dontinclude Tutorial_SavitzkyGolayFilter.C
  @skip main
  @until end of main

@section filtering_calibration Calibration
%OpenMS offers methods for external and internal calibration of raw or peak data.

@subsection filtering_calibration_internal Internal Calibration
The InternalCalibration uses reference masses for calibration. At least two reference masses have to
exist in each spectrum, otherwise it is not calibrated. The data to be calibrated can be raw data or
already picked data. If we have raw data a peak picking step is necessary. For the important peak picking
parameters have a look at the @ref  transformations_pp section.

The following example (Tutorial_InternalCalibration.C) shows how to use the InternalCalibration for raw data.
First the data and reference masses are loaded.

@dontinclude Tutorial_InternalCalibration.C
  @skip  InternalCalibration ic
  @until 2465.19833942

Then we set the important peak picking parameters and run the internal calibration:

@dontinclude Tutorial_InternalCalibration.C
  @skip  Param
  @until ic.calibrate


@subsection filtering_calibration_external External Calibration
The ExternalCalibration uses calibrant spectra to convert a spectrum containing time-of-flight values into one
with m/z values. For the calibrant spectra the expected masses need to be known as wells as
calibration constants to convert the calibrant spectra tof into m/z (determined by the instrument). Using the
calibrant spectra's tof and m/z-values first a quadratic curve fitting is done. The remaining error is estimated
by a spline curve fitting. The quadratic function and the splines are used to determine the calibration equation
for the conversion of the experimental data.

The following example (Tutorial_ExternalCalibration.C) shows how to use the ExternalCalibration for raw data.
First the spectra and reference masses are loaded.

@dontinclude Tutorial_ExternalCalibration.C
  @skip  ExternalCalibration
  @until }

Then we set the calibration constants	for the calibrant spectra.

@dontinclude Tutorial_ExternalCalibration.C
@skip  std::vector
  @until ec.setML3s

Finally we set the important peak picking parameters and run the external calibration:

@dontinclude Tutorial_ExternalCalibration.C
@skip   Param
  @until ec.calibrate


*/

//####################################### CHEMISTRY #######################################

/**

@page tutorial_chemistry Chemistry

Especially for peptide/protein identification a lot of data and datastructures for
chemical entities are needed. OpenMS offers classes for elements, formulas, peptides, etc.
The classes described in this section can be found in the @a CHEMISTRY folder.

@section Elements

There is a representation of Elements implemented in %OpenMS. The correcsponding class is named @a Element. This class stores the relevant information about an element. The handling of the Elements are done by the class ElementDB, which is implemented as an singleton. This means there is only one instance of the class in %OpenMS. This is straightforward because the Elements do not change during execution. Data stored in an Element spans its name, symbol, atomic weight, and isotope distribution beside others.

@dontinclude Tutorial_Element.C
@skip ElementDB* db
	@until endl

Elements can be accessed by the @a ElementDB class. As it is implemented as a singleton only a pointer of the singleton can be used, via @a getInstance(). The example program writes the following output to the console.

	@code
		Carbon C 12 12.0107
	@endcode


@section EmpiricalFormula

The Elements described in the section above can be combined to empirical formulas. Application are the exact weights of molecules, like peptides and their isotopic distributions. The class support a large number of operations like addition and substraction. A simple example is given in the next few lines of code.

@dontinclude Tutorial_EmpiricalFormula.C
@skip methanol
	@until endl

Two instances of empirical formula are created. They are summed up, and some information about the new formula is printed to the terminal. The next lines show how to create and handle a isotopic distribution of a given formula.

@skip iso_dist
	@until }

The isotopic distribution can be simply accessed by the @a getIsotopeDistribution() function. The parameter of this function describes how many isotopes should be reported. In our case, 3 are enough, as the following numbers get very small. On larger molecules, or when one want to have the exact distribution, this number can be set much higher. The output of the code snipped might look like this.

	@code
		O2CH6 1 50.0571
		50 0.98387
		51 0.0120698
		52 0.00406
	@endcode


@section Residue

A residue is represented in %OpenMS by the class @a Residue. It provides a container for the amino acids as well as some functionality. The class is able to provide information such as the isotope distribution of the residue, the average and monoisotopic weight. The residue can be identified by their full name, their three letter abbreviation or the single letter abreviation. The residue can also be modified, which is implemented in the Modification class. Additional less frequently used parameters of a residue like the gas-phase basicity and pk values are also availble.

@dontinclude Tutorial_Residue.C
@skip ResidueDB res_db
	@until endl

This small example show how to create a instance of ResidueDB were all Residues are stored in. The amino acids themselves can be accessed via the getResidue function. ResidueDB read its amino acid and modification data from data/CHEMISTRY/.

The output of the example would look like this

  @code
		Lysine LYS K 146.188
	@endcode


@section AASequence
This class handles the amino acid sequences in %OpenMS. A string of amino acid residues can be turned into a instance of @a AASequence to provide some commonly used operations and data. The implementation supports mathmatical operations like addition or substraction. Also, average and mono isotopic weight and isotope distributions are accessable.

%OpenMS handles mass spectrometry data all the weigths formulas and isotope distribution can be calculated depending on the charge state (additional proton count in case of positive ions) and ion type. Therefore the class allows for a flexible handling of amino acid strings.

A very simple example of handling amino acid sequence with AASequence is given in the next few lines.

@dontinclude Tutorial_AASequence.C
@skip DFPIANGER
	@until endl

Not only the prefix, suffix and subsequence accession is supported, but also most of the features of EmpiricalFormulas and Residues given above. Additionally a number of predictaes like hasSuffix are supported. The output of the code snippet looks like this.

	@code
		DFPIANGER DFPI ANGER 1018.08
	@endcode


@section TheoreticalSpectrumGenerator

This class implements a simple generator to generate tandem MS spectra from a given peptide charge combination. There are various options which influence the occuring ions and their intensities.

@dontinclude Tutorial_TheoreticalSpectrumGenerator.C
@skip tsg
	@until Spectrum 2

The example shows how to put peaks of a certain type, y-ions in this case, into a spectrum. Spectrum 2 is filled with a complete spectrum of all peaks (a-, b-, y-ions and losses). The TheoreticalSpectrumGenerator has many parameters, which have a detailed description located in the class documentation. The output of the program looks like the following two lines.

	@code
		Spectrum 1 has 8 peaks.
		Spectrum 2 has 32 peaks.
	@endcode

*/


//####################################### ANALYSIS #######################################

/**

@page tutorial_analysis High-level data analysis

%OpenMS offers a number of classes for high-level data analysis. This covers map alignment, peptide/protein identification,
clustering, etc.
The classes described in this section can be found in the @a ANALYSIS folder.

@section analysis_mapalignment Map alignment

@subsection analysis_pairwisealignment Pairwise map alignment
The class @a PoseClusteringPairwiseMapMatcher can be used to map the element of one LC-MS map onto the elements of another LC-MS map.
Corresponding elements of the two maps are moved closer together and the retention time as well as the m/z dimensions of the
two maps become comparable.
The transformation which maps one map onto the other is computed during the so called \b superposition \b phase.

\e Superposition \e phase:
In the first step of the superpositon phase an approximation of the transformation is estimated which is used to determine
 reliable landmarks in the two maps. These landmarks enable in the second step the evaluation of a more precise transformation.
 For both steps different classes can be chosen. Using the @a PoseClusteringSuperimposerAffine an affine transformation can be
 estimated and the @a PoseClusteringSuperimposerShift estimes a transformation consisting of only a translation in rt and m/z.
 Given a first approximation of the underlying warp, the @a SimplePairFinder or the @a DelaunayPairFinder can be used to determine
 landmarks in the two maps which represent potential corresponding elements. These landmarks are used by the @a MapMatcherRegression
 to improve the inital transformation.
The following example (Tutorial_PairwiseAlignment.C) shows how to use the @a PoseClusteringPairwiseMapMatcher and the @a MapMatcherRegression for the pairwise alignment of two maps.
The @a PoseClusteringPairwiseMapMatcher is based on the @a PoseClusteringSuperimposerAffine, and a @a DelaunayPairFinder.
The initial as well as the final transformation are stored in gridXML format.

We load two feature maps and instantiate a @a PoseClusteringPairwiseMapMatcher object. The @a PoseClusteringPairwiseMapMatcher
gets references to both maps and a @a Param object which defines the type of transformation and pairfinder.
Additionally the value of <tt>mz_bucket_size</tt> is set, which represents the maximal deviation in m/z of two corresponding elements.
@dontinclude Tutorial_PairwiseAlignment.C
  @skip main
  @until pcpm.run();
The @a PoseClusteringPairwiseMapMatcher determines a vector of element pairs and an initial estimate of the transformation.
We store this initial transformation under "FirstAffineTransformation.gridXML" and pass the
element pairs along with the initial transformation to a @a MapMatcher object.
  @until lr.setGrid(
Using these landmarks an improved transformation is estimated and stored under "SecondAffineTransformation.gridXML"
  @until end of main
@note The class @a MapDewarper can be used to apply the transformation to the elements of a map.


@subsection analysis_multiplealignment Multiple map alignment
The @a StarwiseAlignment class performs a star-like progressive multiple LC-MS map alignment based upon pairwise alignments as described above.
Depending on the processing state of the input maps the output of a multiple alignment varies.
Peak maps are iteratively mapped onto one reference map and the result of the multiple peak map alignment are the dewarped maps themself.
In case of multiple feature maps corresponding elements in all maps are determined during the so called \b consensus \b phase and
are combined to a @a ConsensusMap using @a DelaunayPairFinder.
The @a StarwiseAlignment is able to compute the alignment of multiple peak, feature, or consensus maps.
It provides the warps of all maps relative to the reference map as a result for the alignment of peak maps and computes a @a ConsensusMap as
a result of a multiple feature, or consensus map alignment.
The transformations can be stored in gridXML format using the @a GridFile as mentioned in the example above and can be applied to the maps using
the @a MapDewarper. The @a ConsensusMap can be stored in ConsensusXML using a @a ConsensusXMLFile.

@section analysis_id Identification


*/

//####################################### HOWTO #######################################

/**

@page tutorial_howto HowTo

@section howto_algorithm Creating a new algorithm

Most of the algorithms in %OpenMS share the following base classes:
- @a ProgressLogger is used to report the progress of the algorithm.
- @a DefaultParamHandler is used to make the handling of parameters (and their defaults) easy. @n
  In most cases you will not even need accessors for single parameters.

The interfaces of an algorithm depend on the datastructures it works on.
For an algorithm that work on peak data, a non-template class should be used that provides templates methods operating
on @a MSExperiment or @a MSSpectrum, no matter what peak type is used.
See @a PeakPickerCWT for an example.

For algorithms that do not work on peak data, templates should be avoided.

*/
