// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2009 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Andreas Bertsch $
// $Authors: Andreas Bertsch $
// --------------------------------------------------------------------------

#ifndef OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H
#define OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H

#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/FeatureFinderAlgorithm.h>
#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/ProductModel.h>
#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/EmgFitter1D.h>
#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/EmgModel.h>
#include <OpenMS/FILTERING/SMOOTHING/SavitzkyGolayFilter.h>
#include <OpenMS/DATASTRUCTURES/Map.h>
#include <OpenMS/FILTERING/NOISEESTIMATION/SignalToNoiseEstimatorMeanIterative.h>
#include <OpenMS/FILTERING/TRANSFORMERS/LinearResampler.h>
#include <OpenMS/KERNEL/StandardTypes.h>

#include <boost/math/special_functions/fpclassify.hpp>

#include <fstream>
#include <limits>

namespace OpenMS
{
	/** 
		@brief FeatureFinderAlgorithm for MRM experiments.

		@experimental This tool has not been tested thoroughly and might behave not as expected!

		This very simple algorithm has mainly been tested on dated generated 
		on an ABI/SCIEX QTrap 4000. Maybe this algorithm cannot be directly
		applied on data generated by other mass spectrometers.

    @htmlinclude OpenMS_FeatureFinderAlgorithmMRM.parameters

		@ingroup FeatureFinder
	*/
	template<class PeakType, class FeatureType> class FeatureFinderAlgorithmMRM 
		: public FeatureFinderAlgorithm<PeakType, FeatureType>,
			public FeatureFinderDefs
	{
		public:
			///@name Type definitions
			//@{
			typedef typename FeatureFinderAlgorithm<PeakType, FeatureType>::MapType MapType;
			typedef typename MapType::SpectrumType SpectrumType;
			typedef typename SpectrumType::FloatDataArrays FloatDataArrays;
			//@}
			
			using FeatureFinderAlgorithm<PeakType, FeatureType>::param_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::features_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::ff_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::defaults_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::map_;
				
		public:

			enum
      {
        RT = Peak2D::RT,
        MZ = Peak2D::MZ
      };


			/// default constructor 
			FeatureFinderAlgorithmMRM() 
				: FeatureFinderAlgorithm<PeakType,FeatureType>()
			{
				defaults_.setValue("binning_factor", 1000, "Factor which is used to descretize the m/z positions of the peaks.", StringList::create("advanced"));
				defaults_.setMinInt("binning_factor",1);
				defaults_.setValue("min_rt_distance", 30.0, "Minimal distance of MRM features in seconds.");
				defaults_.setMinFloat("min_rt_distance", 0.0);
				defaults_.setValue("min_num_peaks_per_feature", 5, "Minimal number of peaks which are needed for a single feature", StringList::create("advanced"));
				defaults_.setMinInt("min_num_peaks_per_feature", 1);
				defaults_.setValue("min_signal_to_noise_ratio", 2.0, "Minimal S/N ratio a peak must have to be taken into account.");
				//defaults_.setMinFloat("min_signal_to_noise_ratio", 1.0);
				defaults_.setValue("write_debuginfo", "false", "If set to true, for each feature a plot will be created, in the subdirectory 'debug'", StringList::create("advanced"));
				defaults_.setValidStrings("write_debuginfo", StringList::create("true,false"));
				
				this->defaultsToParam_();
			}
			
			/// Main method for actual FeatureFinder
			virtual void run()
			{
				//-------------------------------------------------------------------------
				//General initialization
				//-------------------------------------------------------------------------

				Map<Size, Map<Size, std::vector<std::pair<DoubleReal, PeakType> > > > traces;
				DoubleReal binning_factor(param_.getValue("binning_factor"));

				ff_->startProgress(0, map_->size(), "Finding MRM traces.");	
				for (Size i = 0; i != map_->size(); ++i)
				{
					DoubleReal prec_mz(0.0);
					DoubleReal rt((*map_)[i].getRT());
					if ((*map_)[i].getPrecursors().size() != 0)
					{
						prec_mz = (*map_)[i].getPrecursors().begin()->getMZ();
					}
					Size prec_bin((Size)(prec_mz * binning_factor));
					for (Size j = 0; j != (*map_)[i].size(); ++j)
					{
						Size frag_bin((Size)((*map_)[i][j].getMZ() * binning_factor));
						traces[prec_bin][frag_bin].push_back(std::make_pair(rt, (*map_)[i][j]));
					}
					ff_->setProgress(i);
				}
				ff_->endProgress();
				
				SignalToNoiseEstimatorMeanIterative<RichPeakSpectrum> sne;
				LinearResampler resampler;

				// Split the whole map into traces (== MRM transitions)
				ff_->startProgress(0, traces.size(), "Finding features in traces.");
				Size counter(0);
				typename Map<Size, Map<Size, std::vector<std::pair<DoubleReal, PeakType> > > >::const_iterator it1 = traces.begin();
				typename Map<Size, std::vector<std::pair<DoubleReal, PeakType> > >::const_iterator it2;
				DoubleReal min_rt_distance(param_.getValue("min_rt_distance"));
				DoubleReal min_signal_to_noise_ratio(param_.getValue("min_signal_to_noise_ratio"));
				Size min_num_peaks_per_feature((UInt)param_.getValue("min_num_peaks_per_feature"));
				Size feature_id(0);
				//bool write_debuginfo(param_.getValue("write_debuginfo").toBool());
				for (; it1 != traces.end(); ++it1)
				{
					for (it2 = it1->second.begin(); it2 != it1->second.end(); ++it2)
					{
						//std::cerr << "Found trace, MS1=" << it1->first / binning_factor << ", MS3=" << it2->first / binning_factor << ", #peaks=" << it2->second.size() << std::endl;

						// throw the peaks into a "spectrum" where the m/z values are RTs in reality (more a chromatogram)
						RichPeakSpectrum chromatogram;
						typename std::vector<std::pair<DoubleReal, PeakType> >::const_iterator it3 = it2->second.begin();
						for (; it3 != it2->second.end(); ++it3)
						{
							RichPeak1D peak;
							peak.setMZ(it3->first);
							peak.setIntensity(it3->second.getIntensity());
							chromatogram.push_back(peak);
						}
				
						// TODO
						// find presection of separated RTs of peaks;
						// resampling to min distance?
						// for each of the section, try to estimate S/N
						// find core regions and fit them
						// report features
						//
						/*
						// resample the chromatogram, first find minimal distance and use this as resampling distance
						DoubleReal min_distance(std::numeric_limits<DoubleReal>::max()), old_rt(0);
						for (RichPeakSpectrum::ConstIterator it = chromatogram.begin(); it != chromatogram.end(); ++it)
						{
							std::cerr << "CHROMATOGRAM: " << it->getMZ() << " " << it->getIntensity() << std::endl;
							DoubleReal rt_diff = it->getMZ() - old_rt;
							if (rt_diff < min_distance && rt_diff > 0)
							{
								min_distance = rt_diff;
							}
							old_rt = it->getMZ();
						}
						
						std::cerr << "Min_distance=" << min_distance << std::endl;

						if (min_distance > 50 || chromatogram.size() < min_num_peaks_per_feature)
						{
							continue;
						}

						Param resampler_param(resampler.getParameters());
						resampler_param.setValue("spacing", min_distance);
						resampler.setParameters(resampler_param);
						resampler.raster(chromatogram);
						*/

						// now smooth the data
						SavitzkyGolayFilter filter;
						Param filter_param(filter.getParameters());
						filter_param.setValue("frame_length", 5);
						filter.setParameters(filter_param);
						filter.filter(chromatogram);

						// calculate signal to noise levels
						RichPeakSpectrum sn_chrom;
						Param sne_param(sne.getParameters());
						// set window length to whole range, we expect only at most one signal
						//std::cerr << "win_len m/z: " <<  (chromatogram.end()-1)->getMZ() << " " << chromatogram.begin()->getMZ() << std::endl;
						sne_param.setValue("win_len", (chromatogram.end()-1)->getMZ() - chromatogram.begin()->getMZ());

						if ((DoubleReal)sne_param.getValue("win_len") < 10e-4)
						{
							continue;
						}
						sne.setParameters(sne_param);
						sne.init(chromatogram.begin(), chromatogram.end());

						//std::cerr << (DoubleReal)it1->first  / (DoubleReal)binning_factor << " " << (DoubleReal)it2->first / (DoubleReal)binning_factor << " ";
						for (RichPeakSpectrum::Iterator sit = chromatogram.begin(); sit != chromatogram.end(); ++sit)
						{
							DoubleReal sn(sne.getSignalToNoise(sit));
							sit->setMetaValue("SN", sn);
							std::cerr << sit->getMZ() << " " << sit->getIntensity() << " " << sn << std::endl;
							if (sn > min_signal_to_noise_ratio)
							{
								sn_chrom.push_back(*sit);
							}
						}

						// now find sections in the chromatogram which have high s/n value
						DoubleReal last_rt(0), this_rt(0);
						std::vector<std::vector<DPosition<2> > > sections;
						for (RichPeakSpectrum::Iterator sit = sn_chrom.begin(); sit != sn_chrom.end(); ++sit)
						{
							//std::cerr << "SECTIONS: " << sit->getMZ() << " " << sit->getIntensity() << std::endl;
							this_rt = sit->getMZ();
							//std::cerr << this_rt << " " << last_rt << std::endl;
							if (sections.size() == 0 || (this_rt - last_rt) > min_rt_distance)
							{
								// new section
								std::vector<DPosition<2> > section;
								section.push_back(DPosition<2>(this_rt, sit->getIntensity()));
								sections.push_back(section);
							}
							else
							{
								sections.back().push_back(DPosition<2>(this_rt, sit->getIntensity()));
							}
							last_rt = this_rt;
						}

						// for each section estimate the rt min/max and add up the intensities
						for (Size i = 0; i != sections.size(); ++i)
						{
							if (sections[i].size() > min_num_peaks_per_feature)
							{
								std::vector<PeakType> data_to_fit;
								for (Size j = 0; j != sections[i].size(); ++j)
								{
									PeakType p;
									p.setPosition(sections[i][j].getX());
									p.setIntensity(sections[i][j].getY());
									data_to_fit.push_back(p);
								}
								InterpolationModel* model_rt = 0;
								DoubleReal quality = fitRT_(data_to_fit, model_rt);

								Feature f;
								f.setQuality(0, quality);
								f.setOverallQuality(quality);

								ConvexHull2D::PointArrayType hull_points(sections[i].size());
								DoubleReal intensity_sum(0.0), rt_sum(0.0);
			          for (Size j = 0; j < sections[i].size(); ++j)
			          {
			            hull_points[j][0] = sections[i][j].getX();
									hull_points[j][1] = (DoubleReal)it2->first / (DoubleReal)binning_factor;

									rt_sum += sections[i][j].getX();
									intensity_sum += sections[i][j].getY();
			          }

								f.setRT(rt_sum / (DoubleReal)sections[i].size());
								f.setMZ((DoubleReal)it2->first / (DoubleReal)binning_factor);
								f.setIntensity(intensity_sum);
								f.getConvexHulls().push_back(hull_points);
								f.setMetaValue("MZ", (DoubleReal)it1->first / (DoubleReal)binning_factor);


								// add the model to the feature
								ProductModel<2> prod_model;
								prod_model.setModel(RT, model_rt);
								f.setModelDescription(ModelDescription<2>(&prod_model));

								
								feature_id++;
								//if (write_debuginfo)
								//{
									String base_name = "debug/" + String((DoubleReal)f.getMetaValue("MZ")) + "_id" + String(feature_id) + "_RT" + String(f.getRT()) + "_Q3" + String(f.getMZ());
									std::ofstream data_out(String(base_name + "_data.dat").c_str());
									for (Size j = 0; j < sections[i].size(); ++j)
									{
										// RT intensity
										DoubleReal rt = sections[i][j].getX();
										DoubleReal intensity = sections[i][j].getY();
										data_out << rt << " " << intensity << std::endl;
									}

									data_out.close();

									std::ofstream fit_out(String(base_name + "_rt_fit.dat").c_str());
									EmgModel emg_model;
									emg_model.setParameters(model_rt->getParameters());
									emg_model.setSamples();
									DoubleReal bb_min((DoubleReal)emg_model.getParameters().getValue("bounding_box:min"));
									DoubleReal bb_max((DoubleReal)emg_model.getParameters().getValue("bounding_box:max"));
									DoubleReal int_step((DoubleReal)emg_model.getParameters().getValue("interpolation_step"));
								  for (DoubleReal pos = bb_min; pos < bb_max; pos += int_step)
								  {
										// RT intensity
								    fit_out << pos << " " << emg_model.getIntensity(pos) << std::endl;
									}
									fit_out.close();

									std::ofstream gnuplot_out(String(base_name + "_gnuplot.gpl").c_str());
									gnuplot_out << "set terminal png" << std::endl;
									gnuplot_out << "set output \"" << base_name << ".png\"" << std::endl;
									gnuplot_out << "plot '" << base_name << "_data.dat' w i, '" << base_name << "_rt_fit.dat' w lp title 'quality=" << f.getOverallQuality() << "'" << std::endl;
									gnuplot_out.close();
									String gnuplot_call = "gnuplot " + base_name + "_gnuplot.gpl";
									int error = system(gnuplot_call.c_str());
									if (error != 0)
									{
										std::cerr << "An error occurred during the gnuplot execution" << std::endl;
									}
								//}

								features_->push_back(f);
							}
						}
					}
					ff_->setProgress(++counter);
				}
				ff_->endProgress();

				

				// 
			}			
	
			static FeatureFinderAlgorithm<PeakType,FeatureType>* create()
			{
				return new FeatureFinderAlgorithmMRM();
			}

			static const String getProductName()
			{
				return "MRM";
			}
	
		protected:

			DoubleReal fitRT_(std::vector<PeakType>& rt_input_data, InterpolationModel*& model) const
    	{
      	DoubleReal quality;
      	Param param;
      	EmgFitter1D fitter;

				/*
      	param.setValue( "tolerance_stdev_bounding_box", tolerance_stdev_box_);
      	param.setValue( "statistics:mean", rt_stat_.mean() );
      	param.setValue( "statistics:variance", rt_stat_.variance() );
      	param.setValue( "interpolation_step", interpolation_step_rt_ );
      	param.setValue( "max_iteration", max_iteration_);
      	param.setValue( "deltaAbsError", deltaAbsError_);
      	param.setValue( "deltaRelError", deltaRelError_);
				*/

      	// Set parameter for fitter
      	fitter.setParameters( param );

      	// Construct model for rt
      	quality = fitter.fit1d(rt_input_data, model);
      
				// Check quality
      	if (boost::math::isnan(quality) ) quality = -1.0;

      	return quality;
    	}



			//Docu in base class
			virtual void updateMembers_()
			{
			}
	};

} // namespace OpenMS

#endif // OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H
