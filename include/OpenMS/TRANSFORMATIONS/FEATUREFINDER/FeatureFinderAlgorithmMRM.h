// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2009 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Andreas Bertsch $
// --------------------------------------------------------------------------

#ifndef OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H
#define OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H

#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/FeatureFinderAlgorithm.h>
#include <OpenMS/FORMAT/MzDataFile.h>
#include <OpenMS/DATASTRUCTURES/Map.h>
#include <OpenMS/FORMAT/FeatureXMLFile.h>
#include <OpenMS/FILTERING/NOISEESTIMATION/SignalToNoiseEstimatorMeanIterative.h>
#include <OpenMS/KERNEL/StandardTypes.h>

namespace OpenMS
{
	/** 
		@brief FeatureFinderAlgorithm for MRM experiments.

		@experimental This tool has not been tested thoroughly and might behave not as expected!

		This very simple algorithm has mainly been tested on dated generated 
		on an ABI/SCIEX QTrap 4000. Maybe this algorithm cannot be directly
		applied on data generated by other mass spectrometers.

    @htmlinclude OpenMS_FeatureFinderAlgorithmMRM.parameters

		@ingroup FeatureFinder
	*/
	template<class PeakType, class FeatureType> class FeatureFinderAlgorithmMRM 
		: public FeatureFinderAlgorithm<PeakType, FeatureType>,
			public FeatureFinderDefs
	{
		public:
			///@name Type definitions
			//@{
			typedef typename FeatureFinderAlgorithm<PeakType, FeatureType>::MapType MapType;
			typedef typename MapType::SpectrumType SpectrumType;
			typedef typename SpectrumType::MetaDataArrays MetaDataArrays;
			//@}
			
			using FeatureFinderAlgorithm<PeakType, FeatureType>::param_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::features_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::ff_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::defaults_;
			using FeatureFinderAlgorithm<PeakType, FeatureType>::map_;
				
		public:			
			/// default constructor 
			FeatureFinderAlgorithmMRM() 
				: FeatureFinderAlgorithm<PeakType,FeatureType>()
			{
				defaults_.setValue("binning_factor", 1000, "Factor which is used to descretize the m/z positions of the peaks.", StringList::create("advanced"));
				defaults_.setMinInt("binning_factor",1);
				defaults_.setValue("min_rt_distance", 30.0, "Minimal distance of MRM features in seconds.");
				defaults_.setMinFloat("min_rt_distance", 0.0);
				defaults_.setValue("min_num_peaks_per_feature", 5, "Minimal number of peaks which are needed for a single feature", StringList::create("advanced"));
				defaults_.setMinInt("min_num_peaks_per_feature", 1);
				defaults_.setValue("min_signal_to_noise_ratio", 2.0, "Minimal S/N ratio a peak must have to be taken into account.");
				defaults_.setMinFloat("min_signal_to_noise_ratio", 1.0);
				
				this->defaultsToParam_();
			}
			
			/// Main method for actual FeatureFinder
			virtual void run()
			{
				//-------------------------------------------------------------------------
				//General initialization
				//-------------------------------------------------------------------------

				Map<Size, Map<Size, std::vector<std::pair<double, PeakType> > > > traces;
				double binning_factor(param_.getValue("binning_factor"));

				ff_->startProgress(0, map_->size(), "Finding MRM traces.");	
				for (Size i = 0; i != map_->size(); ++i)
				{
					double prec_mz(0.0);
					double rt((*map_)[i].getRT());
					if ((*map_)[i].getPrecursors().size() != 0)
					{
						prec_mz = (*map_)[i].getPrecursors().begin()->getMZ();
					}
					Size prec_bin((Size)(prec_mz * binning_factor));
					for (Size j = 0; j != (*map_)[i].size(); ++j)
					{
						Size frag_bin((Size)((*map_)[i][j].getMZ() * binning_factor));
						traces[prec_bin][frag_bin].push_back(std::make_pair(rt, (*map_)[i][j]));
					}
					ff_->setProgress(i);
				}
				ff_->endProgress();
				
				SignalToNoiseEstimatorMeanIterative<RichPeakSpectrum> sne;

				// Split the whole map into traces (== MRM transitions)
				ff_->startProgress(0, traces.size(), "Finding features in traces.");
				Size counter(0);
				typename Map<Size, Map<Size, std::vector<std::pair<double, PeakType> > > >::const_iterator it1 = traces.begin();
				typename Map<Size, std::vector<std::pair<double, PeakType> > >::const_iterator it2;
				double min_rt_distance(param_.getValue("min_rt_distance"));
				double min_signal_to_noise_ratio(param_.getValue("min_signal_to_noise_ratio"));
				Size min_num_peaks_per_feature((UInt)param_.getValue("min_num_peaks_per_feature"));
				for (; it1 != traces.end(); ++it1)
				{
					for (it2 = it1->second.begin(); it2 != it1->second.end(); ++it2)
					{
						//std::cerr << "Found trace, MS1=" << it1->first / binning_factor << ", MS3=" << it2->first / binning_factor << ", #peaks=" << it2->second.size() << std::endl;

						// throw the peaks into a "spectrum" where the m/z values are RTs in reality (more a chromatogram)
						RichPeakSpectrum chromatogram;
						typename std::vector<std::pair<double, PeakType> >::const_iterator it3 = it2->second.begin();
						for (; it3 != it2->second.end(); ++it3)
						{
							RichPeak1D peak;
							peak.setMZ(it3->first);
							peak.setIntensity(it3->second.getIntensity());
							chromatogram.push_back(peak);
						}
						
						// calculate signal to noise levels
						RichPeakSpectrum sn_chrom;
						sne.init(chromatogram.begin(), chromatogram.end());
						for (RichPeakSpectrum::Iterator sit = chromatogram.begin(); sit != chromatogram.end(); ++sit)
						{
							double sn(sne.getSignalToNoise(sit));
							sit->setMetaValue("SN", sn);
							//std::cerr << sit->getMZ() << " " << sit->getIntensity() << " " << sn << std::endl;
							if (sn > min_signal_to_noise_ratio)
							{
								sn_chrom.push_back(*sit);
							}
						}

						// now find sections in the chromatogram which have high s/n value
						double last_rt(0), this_rt(0);
						std::vector<std::vector<DPosition<2> > > sections;
						for (RichPeakSpectrum::Iterator sit = sn_chrom.begin(); sit != sn_chrom.end(); ++sit)
						{
							this_rt = sit->getMZ();
							if ((this_rt - last_rt) > min_rt_distance)
							{
								// new section
								std::vector<DPosition<2> > section;
								section.push_back(DPosition<2>(this_rt, sit->getIntensity()));
								sections.push_back(section);
							}
							else
							{
								sections.back().push_back(DPosition<2>(this_rt, sit->getIntensity()));
							}
							last_rt = this_rt;
						}

						// for each section estimate the rt min/max and add up the intensities
						// TODO do some fitting
						for (Size i = 0; i != sections.size(); ++i)
						{
							if (sections[i].size() > min_num_peaks_per_feature)
							{
								Feature f;
								ConvexHull2D::PointArrayType hull_points(sections[i].size());
								double intensity_sum(0.0), rt_sum(0.0);
			          for (Size j = 0; j < sections[i].size(); ++j)
			          {
			            hull_points[j][0] = sections[i][j].getX();
									hull_points[j][1] = (double)it2->first / binning_factor;

									rt_sum += sections[i][j].getX();
									intensity_sum += sections[i][j].getY();
			          }

								f.setRT(rt_sum / (double)sections[i].size());
								f.setMZ((double)it2->first / binning_factor);
								f.setIntensity(intensity_sum);
								f.getConvexHulls().push_back(hull_points);
								f.setMetaValue("MZ", (double)it1->first / binning_factor);
								features_->push_back(f);
							}
						}
					}
					ff_->setProgress(++counter);
				}
				ff_->endProgress();

				

				// 
			}			
	
			static FeatureFinderAlgorithm<PeakType,FeatureType>* create()
			{
				return new FeatureFinderAlgorithmMRM();
			}

			static const String getProductName()
			{
				return "MRM";
			}
	
		protected:

			//Docu in base class
			virtual void updateMembers_()
			{
			}
	};

} // namespace OpenMS

#endif // OPENMS_TRANSFORMATIONS_FEATUREFINDER_FEATUREFINDERALGORITHMMRM_H
