// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2009 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm, Clemens Groepl $
// $Authors: $
// --------------------------------------------------------------------------

#include <OpenMS/config.h>

#include <OpenMS/FORMAT/FileHandler.h>
#include <OpenMS/FORMAT/FileTypes.h>
#include <OpenMS/FORMAT/FeatureXMLFile.h>
#include <OpenMS/FORMAT/IdXMLFile.h>
#include <OpenMS/FORMAT/ConsensusXMLFile.h>
#include <OpenMS/FORMAT/PeakTypeEstimator.h>
#include <OpenMS/APPLICATIONS/TOPPBase.h>
#include <OpenMS/DATASTRUCTURES/StringList.h>
#include <OpenMS/DATASTRUCTURES/Map.h>

#include <QtCore/QString>

#include <gsl/gsl_sort.h>
#include <gsl/gsl_statistics.h>

using namespace OpenMS;
using namespace std;

//-------------------------------------------------------------
//Doxygen docu
//-------------------------------------------------------------

/**
	@page TOPP_FileInfo FileInfo

	@brief Shows basic information about the data in a file.

	This tool can show basic information about the data in several peak, feature and consensus feature files. It can
	- show information about the data range of a file (m/z, RT, intensity)
	- show a statistical summary for intensities and qualities
	- show an overview of the metadata
	- validate several XML formats against their XML schema
	- check for corrupt data in a file (e.g. dupliacte spectra)

	<B>The command line parameters of this tool are:</B>
	@verbinclude TOPP_FileInfo.cli
*/

// We do not want this class to show up in the docu:
/// @cond TOPPCLASSES

namespace OpenMS
{
	//helper struct for identification data
	struct IdData
	{
		String identifier;
		vector<ProteinIdentification> proteins;
		vector<PeptideIdentification> peptides;
	};
	
	/// A little helper class to gather (and dump) some statistics from a std::vector<double>.  Uses statistical functions implemented in GSL.
	struct SomeStatistics
	{
		/**@brief Initialize SomeStatistics from data.

		@note: GSL statistics uses double and so we write double not DoubleReal here and where we use this.
		*/
		SomeStatistics & operator()(std::vector<double> &data)
		{
			std::sort(data.begin(),data.end());
			mean = gsl_stats_mean(&data.front(),1,data.size());
			variance = gsl_stats_variance_m(&data.front(),1,data.size(),mean);
			min = data.front();
			lowerq = gsl_stats_quantile_from_sorted_data (&data.front(),1,data.size(),0.25);
			median = gsl_stats_median_from_sorted_data(&data.front(),1,data.size());
			upperq = gsl_stats_quantile_from_sorted_data(&data.front(),1,data.size(),0.75);
			max = data.back();
			return *this;
		}
		double mean, variance, min, lowerq, median, upperq, max;
	};
	
	/// Write SomeStatistics to a stream.
	static ostream& operator << (ostream& os, const SomeStatistics& rhs)
	{
		return os <<
			"  mean: " << rhs.mean << "\n"
			"  min: " << rhs.min << "\n"
			"  lower quartile: " << rhs.lowerq << "\n"
			"  median: " << rhs.median << "\n"
			"  upper quartile: " << rhs.upperq << "\n"
			"  max: " << rhs.max << "\n"
			"  variance: " << rhs.variance << '\n';
	}
}

class TOPPFileInfo
	: public TOPPBase
{
 public:
	TOPPFileInfo()
		: TOPPBase("FileInfo","Shows basic information about the file, such as data ranges and file type.")
	{

	}

 protected:

	virtual void registerOptionsAndFlags_()
	{
		registerInputFile_("in","<file>","","input file ");
		setValidFormats_("in",StringList::create("mzData,mzXML,mzML,DTA,DTA2D,cdf,mgf,featureXML,consensusXML,idXML"));
		registerStringOption_("in_type","<type>","","input file type -- default: determined from file extension or content\n", false);
		setValidStrings_("in_type",StringList::create("mzData,mzXML,mzML,DTA,DTA2D,cdf,mgf,featureXML,consensusXML"));
		registerOutputFile_("out","<file>","","Optional output file. If '-' or left out, the output is written to the command line.", false);
		registerFlag_("m","Show meta information about the whole experiment");
		registerFlag_("s","Computes a five-number statistics of intensities and qualities");
		registerFlag_("d","Show detailed listing of all spectra (peak files only)");
		registerFlag_("c","Check for corrupt data in the file (peak files only)");
		registerFlag_("v","Validate the file only (for mzData, mzXML, featureXML, IdXML, consensusXML)");
	}

	ExitCodes outputTo(ostream& os)
	{
		//-------------------------------------------------------------
		// parameter handling
		//-------------------------------------------------------------

		//file names
		String in = getStringOption_("in");

		//file type
		FileHandler fh;
		FileTypes::Type in_type = fh.nameToType(getStringOption_("in_type"));

		if (in_type==FileTypes::UNKNOWN)
		{
			in_type = fh.getType(in);
			writeDebug_(String("Input file type: ") + fh.typeToName(in_type), 2);
		}

		if (in_type==FileTypes::UNKNOWN)
		{
			writeLog_("Error: Could not determine input file type!");
			return PARSE_ERROR;
		}

		os << endl
				 << "-- General information --" << endl
				 << endl
				 << "file name: " << in << endl
				 << "file type: " <<  fh.typeToName(in_type) << endl;

		MSExperiment<Peak1D> exp;
		FeatureMap<> feat;
		ConsensusMap cons;
		IdData id_data;

		//-------------------------------------------------------------
		// validation
		//-------------------------------------------------------------
		if (getFlag_("v"))
		{
			bool valid = true;
			os << endl << "Validating " << fh.typeToName(in_type) << " file";
			switch(in_type)
			{
				case FileTypes::MZDATA :
					os << " against XML schema version " << MzDataFile().getVersion() << endl;
					valid = MzDataFile().isValid(in,os);
					break;
				case FileTypes::MZML :
					os << " against XML schema version " << MzMLFile().getVersion() << endl;
					valid = MzMLFile().isValid(in,os);
					break;
				case FileTypes::FEATUREXML :
					os << " against XML schema version " << FeatureXMLFile().getVersion() << endl;
					valid = FeatureXMLFile().isValid(in,os);
					break;
				case FileTypes::IDXML :
					os << " against XML schema version " << IdXMLFile().getVersion() << endl;
					valid = IdXMLFile().isValid(in,os);
					break;
				case FileTypes::CONSENSUSXML :
					os << " against XML schema version " << ConsensusXMLFile().getVersion() << endl;
					valid = ConsensusXMLFile().isValid(in,os);
					break;
				case FileTypes::MZXML :
					os << " against XML schema version " << MzXMLFile().getVersion() << endl;
					valid = MzXMLFile().isValid(in,os);
					break;
				default:
					os << endl << "Aborted: Validation of this file type is not supported!" << endl;
					return EXECUTION_OK;
			};

			if (valid)
			{
				os << "Success: fhe file is valid!" << endl;
			}
			else
			{
				os << "Failed: errors are listed above!" << endl;
			}

			if (in_type==FileTypes::MZML)
			{
				if (!valid)
				{
					os << endl << "Semantic validation is not perfomed due to previous errors! " << endl;
				}
				else
				{
					os << endl << "Semantically validating " << fh.typeToName(in_type) << " file:" << endl;
					StringList errors, warnings;
					valid = MzMLFile().isSemanticallyValid(in, errors, warnings);
					for (Size i=0; i<warnings.size(); ++i)
					{
						os << "Warning: " << warnings[i] << endl;
					}
					for (Size i=0; i<errors.size(); ++i)
					{
						os << "Error: " << errors[i] << endl;
					}
					if (valid)
					{
						os << "Success: fhe file is semantically valid!" << endl;
					}
					else
					{
						os << "Failed: errors are listed above!" << endl;
					}
				}
			}

			return EXECUTION_OK;
		}

		//-------------------------------------------------------------
		// content statistics
		//-------------------------------------------------------------
		Map<String,int> meta_names;
		if (in_type==FileTypes::FEATUREXML) //features
		{
			FeatureXMLFile().load(in,feat);
			feat.updateRanges();

			os << "Number of features: " << feat.size() << endl
				 << endl
				 << "retention time range: " << feat.getMin()[Peak2D::RT] << " / " << feat.getMax()[Peak2D::RT] << endl
				 << "m/z range: " << feat.getMin()[Peak2D::MZ] << " / " << feat.getMax()[Peak2D::MZ] << endl
				 << "intensity range: " << feat.getMinInt() << " / " << feat.getMaxInt() << endl
				 << endl;

			//Charge distribution
			Map<UInt,UInt> charges;
			for (Size i=0; i< feat.size(); ++i)
			{
				charges[feat[i].getCharge()]++;
			}

			os << "Charge distribution" << endl;
			for (Map<UInt,UInt>::const_iterator it=charges.begin(); it!=charges.end(); ++it)
			{
				os << "charge " << it->first << ": " << it->second << endl;
			}
		}
		else if (in_type==FileTypes::CONSENSUSXML) //consensus features
		{
			ConsensusXMLFile().load(in,cons);
			cons.updateRanges();

			std::map<Size,UInt> num_consfeat_of_size;
			for ( ConsensusMap::const_iterator cmit = cons.begin(); cmit != cons.end(); ++cmit )
			{
				++num_consfeat_of_size[cmit->size()];
			}

			os <<
				"\n"
				"Number of consensus features:" << std::endl;
			for ( std::map<Size,UInt>::reverse_iterator i = num_consfeat_of_size.rbegin(); i != num_consfeat_of_size.rend(); ++i )
			{
				os << "  of size " << std::setw(2) << i->first << ": " << std::setw(6) << i->second << '\n';
			}
			os << "  total:      " << std::setw(6) << cons.size() << '\n';

			os <<
				"\n"
				"Ranges:\n"
				"  retention time:  " << precisionWrapper(cons.getMin()[Peak2D::RT]) << " : " << precisionWrapper(cons.getMax()[Peak2D::RT]) << "\n"
				"  mass-to-charge:  " << precisionWrapper(cons.getMin()[Peak2D::MZ]) << " : " << precisionWrapper(cons.getMax()[Peak2D::MZ]) << "\n"
				"  intensity:       " << precisionWrapper(cons.getMinInt()) << " : " << precisionWrapper(cons.getMaxInt()) <<
				std::endl;

			//file descriptions
			const ConsensusMap::FileDescriptions& descs = cons.getFileDescriptions();
			if (descs.size()!=0)
			{
				os <<
					"\n"
					"File descriptions:\n";
				for (ConsensusMap::FileDescriptions::const_iterator it=descs.begin(); it!=descs.end(); ++it)
				{
					os << " - " << it->second.filename << endl
							 << "   identifier: " << it->first << endl
							 << "   label     : " << it->second.label << endl
							 << "   size      : " << it->second.size << endl;
				}
			}
		}
		else if (in_type==FileTypes::IDXML) //identifications
		{

			UInt spectrum_count = 0;
			Size peptide_hit_count = 0;
			UInt runs_count = 0;
			Size protein_hit_count = 0;
			vector<String> peptides;
			vector<String> proteins;
			
			// reading input
			IdXMLFile().load(in, id_data.proteins, id_data.peptides, id_data.identifier);
						
			// calculations
			for (Size i = 0; i < id_data.peptides.size(); ++i)
			{
				if (!id_data.peptides[i].empty())
				{
					++spectrum_count;
					peptide_hit_count += id_data.peptides[i].getHits().size();
					const vector<PeptideHit>& temp_hits = id_data.peptides[i].getHits();
					for (Size j = 0; j < temp_hits.size(); ++j)
					{
						if (find(peptides.begin(), peptides.end(), temp_hits[j].getSequence().toString()) == peptides.end())
						{
							peptides.push_back(temp_hits[j].getSequence().toString());
						}
					}
				}
			} 
			for (Size i = 0; i < id_data.proteins.size(); ++i)
			{
				++runs_count;
				protein_hit_count += id_data.proteins[i].getHits().size();
				const vector<ProteinHit>& temp_hits = id_data.proteins[i].getHits();
				for (Size j = 0; j < temp_hits.size(); ++j)
				{
					if (find(proteins.begin(), proteins.end(), temp_hits[j].getAccession()) == proteins.end())
					{
						proteins.push_back(temp_hits[j].getAccession());
					}
				}
			}
			
			cout << "Number of runs: " << runs_count << endl;
			cout << "Number of protein hits: " << protein_hit_count << endl;
			cout << "Number of unique protein hits: " << proteins.size() << endl;
			cout << endl;
			cout << "Number of spectra: " << spectrum_count << endl;
			cout << "Number of peptide hits: " << peptide_hit_count << endl;
			cout << "Number of unique peptide hits: " << peptides.size() << endl;
		}
		else //peaks
		{
			if (! fh.loadExperiment(in,exp,in_type,log_type_) )
			{
				writeLog_("Unsupported or corrupt input file. Aborting!");
				printUsage_();
				return ILLEGAL_PARAMETERS;
			}

			//check if the meta data indicates that this is peak data
			UInt meta_type = SpectrumSettings::UNKNOWN;
			for (Size i=0; i<exp.getDataProcessing().size(); ++i)
			{
				if (exp.getDataProcessing()[i].getProcessingActions().count(DataProcessing::PEAK_PICKING)==1)
				{
					meta_type = SpectrumSettings::PEAKS;
				}
			}
			//determine type (search for the first scan with at least 5 peaks)
			UInt type = SpectrumSettings::UNKNOWN;
			UInt i=0;
			while(i<exp.size() && exp[i].size()<5) ++i;
			if (i!=exp.size())
			{
				type = PeakTypeEstimator().estimateType(exp[i].begin(),exp[i].end());
			}
			os << endl
					 << "peak type (metadata) : " << SpectrumSettings::NamesOfSpectrumType[meta_type] << endl
					 << "peak type (estimated): " << SpectrumSettings::NamesOfSpectrumType[type] << endl;
			//if raw data, determine the spacing
			if (type==SpectrumSettings::RAWDATA)
			{
				vector<Real> spacing;
				for (Size j=1; j<exp[i].size(); ++j)
				{
					spacing.push_back(exp[i][j].getMZ()-exp[i][j-1].getMZ());
				}
				std::sort(spacing.begin(),spacing.end());
				os << "estimated raw data spacing: " << spacing[spacing.size()/2] << " (min: " << spacing[0] << " max: " << spacing.back() << ")" << endl;
			}
			os << endl;

			//basic info
			exp.updateRanges();
			vector<UInt> levels = exp.getMSLevels();

			os << "Number of peaks: " << exp.getSize() << endl
					 << endl
					 << "retention time range: " << exp.getMinRT() << " / " << exp.getMaxRT() << endl
					 << "m/z range: " << exp.getMinMZ() << " / " << exp.getMaxMZ() << endl
					 << "intensity range: " << exp.getMinInt() << " / " << exp.getMaxInt() << endl
					 << "MS levels: ";
			if (levels.size()!=0)
			{
				os << *(levels.begin());
				for (vector<UInt>::iterator it = ++levels.begin(); it != levels.end(); ++it)
				{
					os << ", " << *it;
				}
			}
			os << endl << endl;

			//count how many spectra per MS level there are
			vector<UInt> counts(5);
			for (MSExperiment<Peak1D>::iterator it = exp.begin(); it!=exp.end(); ++it)
			{
				counts[it->getMSLevel()]++;
			}
			//output
			for (Size i = 0; i!=5; ++i)
			{
				if (counts[i]!=0)
				{
					os << "Spectra of MS Level " << i << ": " << counts[i] << endl;
				}
			}
			os << endl;

			//show meta data array names
			for (MSExperiment<Peak1D>::iterator it = exp.begin(); it!=exp.end(); ++it)
			{
				for (i=0; i<it->getMetaDataArrays().size();++i)
				{
					String name = it->getMetaDataArrays()[i].getName();
					if (meta_names.has(name))
					{
						meta_names[name]++;
					}
					else
					{
						meta_names[name] = 1;
					}
				}
			}
			if (!meta_names.empty())
			{
				for (Map<String,int>::ConstIterator it=meta_names.begin();it!=meta_names.end();++it)
				{
					os << "Meta data array: " << it->first << " (for " << it->second << " spectra)" << endl;
				}
				os << endl;
			}

			// Detailed listing of scans
			if (getFlag_("d"))
			{
				os << endl
						 << "-- Detailed spectrum listing --" << endl
						 << endl;
				UInt count=0;
				for (MSExperiment<Peak1D>::iterator it = exp.begin(); it!=exp.end(); ++it)
				{
					++count;
					os << "spectrum " << count << " - mslevel:" << it->getMSLevel() << " scanMode:" << InstrumentSettings::NamesOfScanMode[it->getInstrumentSettings().getScanMode()] << " peaks:" << it->size() << " RT:" << it->getRT() << " m/z:";
					if (it->size()!=0)
					{
						os << it->begin()->getMZ() << "-" << (it->end()-1)->getMZ();
					}
					os << endl;
				}
			}

			//Check for corrupt data
			if (getFlag_("c"))
			{
				os << endl
						 << "-- Checking for corrupt data --" << endl
						 << endl;
				std::vector<DoubleReal> rts;
				rts.reserve(exp.size());
				for (Size s=0; s<exp.size();++s)
				{
					//ms level = 0
					if (exp[s].getMSLevel()==0)
					{
						os << "Error: MS-level 0 in spectrum (RT: " << exp[s].getRT() << ")" << std::endl;
					}
					//duplicate scans
					if (exp[s].getMSLevel()==1)
					{
						if (find(rts.begin(),rts.end(),exp[s].getRT())!=rts.end())
						{
							os << "Error: Duplicate spectrum retention time: " << exp[s].getRT() << std::endl;
						}
						rts.push_back(exp[s].getRT());
					}
					//scan size = 0
					if (exp[s].size()==0)
					{
						os << "Warning: No peaks in spectrum (RT: " << exp[s].getRT() << ")" << std::endl;
					}
					//duplicate meta data array names
					Map<String,int> names;
					for (Size m=0; m<exp[s].getMetaDataArrays().size(); ++m)
					{
						String name = exp[s].getMetaDataArrays()[m].getName();
						if (names.has(name))
						{
							os << "Error: Duplicate meta data array name '" << name << "' in spectrum (RT: " << exp[s].getRT() << ")" << std::endl;
						}
						else
						{
							names[name] = 0;
						}
					}
					//check peaks
					std::vector<DoubleReal> mzs;
					mzs.reserve(exp[s].size());
					for (Size p=0; p<exp[s].size();++p)
					{
						//negative intensity
						if (exp[s][p].getIntensity()<0.0)
						{
							os << "Warning: Negative intensity of peak (RT: " << exp[s].getRT() << " RT: " << exp[s][p].getMZ() << ")" << std::endl;
						}
						//duplicate m/z
						if (find(mzs.begin(),mzs.end(),exp[s][p].getMZ())!=mzs.end())
						{
							os << "Warning: Duplicate peak m/z " << exp[s][p].getMZ() << " in spectrum (RT: " << exp[s].getRT() << ")" << std::endl;
						}
						mzs.push_back(exp[s][p].getMZ());
					}
				}
			}
		}

		//-------------------------------------------------------------
		// meta information
		//-------------------------------------------------------------
		if (getFlag_("m"))
		{
			//basic info
			os << endl
					 << "-- Meta information --" << endl
					 << endl;

			if (in_type==FileTypes::FEATUREXML) //features
			{
				os << "Document id       : " << feat.getIdentifier() << endl << endl;
			}
			else if (in_type==FileTypes::CONSENSUSXML) //consensus features
			{
				os << "Document id       : " << cons.getIdentifier() << endl << endl;
			}
			else if (in_type==FileTypes::IDXML) //identifications
			{
				os << "Document id       : " << id_data.identifier << endl << endl;
			}
			else //peaks
			{

				os << "Document id       : " << exp.getIdentifier() << endl
						 << "Date              : " << exp.getDateTime().get() << endl;

				//basic info
				os << endl
						 << "Sample" << endl
						 << "  Name             : " << exp.getSample().getName() << endl
						 << "  Organism         : " << exp.getSample().getOrganism()  << endl
						 << "  Comment          : " << exp.getSample().getComment()  << endl;

				//instrument info
				os << endl
						 << "Instrument" << endl
						 << "  Name             : " << exp.getInstrument().getName() << endl
						 << "  Model            : " << exp.getInstrument().getModel()  << endl
						 << "  Vendor           : " << exp.getInstrument().getVendor()  << endl
						 << "  Ion source(s)    : ";
				for (Size i=0; i< exp.getInstrument().getIonSources().size(); ++i)
				{
					os << IonSource::NamesOfIonizationMethod[exp.getInstrument().getIonSources()[i].getIonizationMethod()];
					if (i!=exp.getInstrument().getIonSources().size()-1) os << ", ";
				}
				os << endl << "  Mass Analyzer(s) : ";
				for (Size i=0; i< exp.getInstrument().getMassAnalyzers().size(); ++i)
				{
					os << MassAnalyzer::NamesOfAnalyzerType[exp.getInstrument().getMassAnalyzers()[i].getType()];
					if (i!=exp.getInstrument().getMassAnalyzers().size()-1) os << ", ";
				}
				os << endl << "  Detector(s)      : ";
				for (Size i=0; i< exp.getInstrument().getIonDetectors().size(); ++i)
				{
					os << IonDetector::NamesOfType[exp.getInstrument().getIonDetectors()[i].getType()];
					if (i!=exp.getInstrument().getIonDetectors().size()-1) os << ", ";
				}
				os << endl << endl;

				//contact persons
				for (Size i=0; i< exp.getContacts().size(); ++i)
				{
					os << "Contact Person" << endl
							 << "  First Name       : " << exp.getContacts()[i].getFirstName() << endl
							 << "  Last Name        : " << exp.getContacts()[i].getLastName() << endl
							 << "  Email            : " << exp.getContacts()[i].getEmail() << endl
							 << endl;
				}
			}
		}

		// '-s' show statistics
		if (getFlag_("s"))
		{
			os << endl
					 << "-- Statistics --" << endl
					 << endl;
			OpenMS::SomeStatistics some_statistics;

			if (in_type==FileTypes::FEATUREXML) //features
			{
				Size size = feat.size();

				std::vector<double> intensities;
				intensities.reserve(size);

				std::vector<double> overallqualities;
				overallqualities.reserve(size);

				std::vector<double> mz_qualities;
				mz_qualities.reserve(size);

				std::vector<double> rt_qualities;
				rt_qualities.reserve(size);

				for (FeatureMap<>::const_iterator fm_iter = feat.begin();
						 fm_iter != feat.end();
						 ++fm_iter
						)
				{
					intensities.push_back(fm_iter->getIntensity());
					overallqualities.push_back(fm_iter->getOverallQuality());
					rt_qualities.push_back(fm_iter->getQuality(Feature::RT));
					mz_qualities.push_back(fm_iter->getQuality(Feature::MZ));
				}

				os.precision(writtenDigits<>(Feature::IntensityType() ));
				os << "Intensities:\n" << some_statistics(intensities) << endl;

				os.precision(writtenDigits<>(Feature::QualityType() ));
				os << "Overall qualities:\n" << some_statistics(overallqualities) << endl;

				os.precision(writtenDigits<>(Feature::QualityType()));
				os << "Qualities in retention time dimension:\n" << some_statistics(rt_qualities) << endl;

				os.precision(writtenDigits<>(Feature::QualityType()));
				os << "Qualities in mass-to-charge dimension:\n" << some_statistics(mz_qualities) << endl;

			}
			else if (in_type==FileTypes::CONSENSUSXML) //consensus features
			{
				Size size = cons.size();

				std::vector<double> intensities;
				intensities.reserve(size);

				std::vector<double> qualities;
				qualities.reserve(size);

				std::vector<double> rt_delta_by_elems;
				std::vector<double> rt_aad_by_elems;
				std::vector<double> rt_aad_by_cfs;
				rt_aad_by_cfs.reserve(size);

				std::vector<double> mz_delta_by_elems;
				std::vector<double> mz_aad_by_elems;
				std::vector<double> mz_aad_by_cfs;
				mz_aad_by_cfs.reserve(size);

				std::vector<double> it_delta_by_elems;
				std::vector<double> it_aad_by_elems;
				std::vector<double> it_aad_by_cfs;
				it_aad_by_cfs.reserve(size);

				for ( ConsensusMap::const_iterator cm_iter = cons.begin();
							cm_iter != cons.end();
							++cm_iter
						)
				{
					double rt_aad = 0;
					double mz_aad = 0;
					double it_aad = 0;
					intensities.push_back(cm_iter->getIntensity());
					qualities.push_back(cm_iter->getQuality());
					for ( ConsensusFeature::HandleSetType::const_iterator hs_iter = cm_iter->begin();
								hs_iter != cm_iter->end();
								++hs_iter
							)
					{
						double rt_diff = hs_iter->getRT() - cm_iter->getRT();
						rt_delta_by_elems.push_back(rt_diff);
						if ( rt_diff < 0 ) rt_diff = -rt_diff;
						rt_aad_by_elems.push_back(rt_diff);
						rt_aad += rt_diff;
						double mz_diff = hs_iter->getMZ() - cm_iter->getMZ();
						mz_delta_by_elems.push_back(mz_diff);
						if ( mz_diff < 0 ) mz_diff = -mz_diff;
						mz_aad_by_elems.push_back(mz_diff);
						mz_aad += mz_diff;
						double it_ratio = hs_iter->getIntensity() / ( cm_iter->getIntensity() ? cm_iter->getIntensity() : 1. );
						it_delta_by_elems.push_back(it_ratio);
						if ( it_ratio < 1. ) it_ratio = 1./it_ratio;
						it_aad_by_elems.push_back(it_ratio);
						it_aad += it_ratio;
					}
					if ( !cm_iter->empty() )
					{
						rt_aad /= cm_iter->size();
						mz_aad /= cm_iter->size();
						it_aad /= cm_iter->size();
					} // otherwise rt_aad etc. are 0 anyway
					rt_aad_by_cfs.push_back(rt_aad);
					mz_aad_by_cfs.push_back(mz_aad);
					it_aad_by_cfs.push_back(it_aad);
				}

				os.precision(writtenDigits(ConsensusFeature::IntensityType()));
				os << "Intensities of consensus features:\n" << some_statistics(intensities) << endl;

				os.precision(writtenDigits(ConsensusFeature::QualityType()));
				os << "Qualities of consensus features:\n" << some_statistics(qualities) << endl;

				os.precision(writtenDigits(ConsensusFeature::CoordinateType()));
				os << "Retention time differences ( element-center, weight 1 per element):\n" << some_statistics(rt_delta_by_elems) << endl;
				os << "Absolute retention time differences ( |element-center|, weight 1 per element):\n" << some_statistics(rt_aad_by_elems) << endl;
				os << "Average absolute differences of retention time within consensus features ( |element-center|, weight 1 per consensus features):\n" << some_statistics(rt_aad_by_cfs) << endl;

				os.precision(writtenDigits(ConsensusFeature::CoordinateType()));
				os << "Mass-to-charge differences ( element-center, weight 1 per element):\n" << some_statistics(mz_delta_by_elems) << std::endl;
				os << "Absolute differences of mass-to-charge ( |element-center|, weight 1 per element):\n" << some_statistics(mz_aad_by_elems) << std::endl;
				os << "Average absolute differences of mass-to-charge within consensus features ( |element-center|, weight 1 per consensus features):\n" << some_statistics(mz_aad_by_cfs) << std::endl;

				os.precision(writtenDigits(ConsensusFeature::IntensityType()));
				os << "Intensity ratios ( element/center, weight 1 per element):\n" << some_statistics(it_delta_by_elems) << std::endl;
				os << "Relative intensity error ( max{(element/center),(center/element)}, weight 1 per element):\n" << some_statistics(it_aad_by_elems) << std::endl;
				os << "Average relative intensity error within consensus features ( max{(element/center),(center/element)}, weight 1 per consensus features):\n" << some_statistics(it_aad_by_cfs) << std::endl;

			}
			else if (in_type==FileTypes::IDXML) //identifications
			{
				//TODO
			}
			else //peaks
			{
				//copy intensities of  MS-level 1 peaks
				exp.updateRanges(1);
				Size size = exp.getSize();
				std::vector<double> intensities;
				intensities.reserve(size);
				for (MSExperiment<Peak1D>::const_iterator spec = exp.begin(); spec != exp.end(); ++spec)
				{
					if (spec->getMSLevel()!=1)
					{
						continue;
					}
					for (MSExperiment<Peak1D>::SpectrumType::const_iterator it = spec->begin(); it!=spec->end(); ++it)
					{
						intensities.push_back(it->getIntensity());
					}
				}

				sort(intensities.begin(),intensities.end());
				os.precision(writtenDigits(Peak1D::IntensityType()));
				os << "Intensities:\n" << some_statistics(intensities) << endl;

				//Statistics for meta information
				for (Map<String,int>::ConstIterator it=meta_names.begin();it!=meta_names.end();++it)
				{
					String name = it->first;
					os << "Meta data: " << name << endl;
					vector<Real> m_values;
					DoubleReal sum = 0.0;
					for (MSExperiment<Peak1D>::const_iterator spec = exp.begin(); spec != exp.end(); ++spec)
					{
						for (Size meta=0; meta<spec->getMetaDataArrays().size(); ++meta)
						{
							if (spec->getMetaDataArrays()[meta].getName()!=name) continue;
							for (Size peak=0; peak < spec->size(); ++peak)
							{
								m_values.push_back(spec->getMetaDataArrays()[meta][peak]);
								sum += spec->getMetaDataArrays()[meta][peak];
							}
						}
					}
					sort(m_values.begin(),m_values.end());
					os << "  count: " << m_values.size() << endl
							 << "  min: " << QString::number(m_values.front(),'f',2).toStdString() << endl
							 << "  max: " << QString::number(m_values.back(),'f',2).toStdString() << endl
							 << "  mean: " << QString::number(sum/m_values.size(),'f',2).toStdString() << endl
							 << "  median: " << QString::number(m_values[m_values.size()/2],'f',2).toStdString() << endl
							 << endl;
				}
			}

		}

		os << endl << endl;

		return EXECUTION_OK;
	}

	ExitCodes main_(int , const char**)
	{
		String out = getStringOption_("out");

		//output to command line
		if (out=="")
		{
			return outputTo(cout);
		}
		//output to file
		else
		{
			ofstream os(out.c_str());
			return outputTo(os);
		}
	}
};

int main( int argc, const char** argv )
{
	TOPPFileInfo tool;
	return tool.main(argc,argv);
}

/// @endcond
