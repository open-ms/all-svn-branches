// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2011 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Clemens Groepl $
// $Authors: Marc Sturm, Clemens Groepl $
// --------------------------------------------------------------------------
#include <OpenMS/FORMAT/MzMLFile.h>
#include <OpenMS/FORMAT/ConsensusXMLFile.h>
#include <OpenMS/FORMAT/FeatureXMLFile.h>
#include <OpenMS/FORMAT/IdXMLFile.h>
#include <OpenMS/FORMAT/FileHandler.h>
#include <OpenMS/FORMAT/FileTypes.h>
#include <OpenMS/FORMAT/TransformationXMLFile.h>
#include <OpenMS/ANALYSIS/MAPMATCHING/MapAlignmentAlgorithm.h>


#include <OpenMS/APPLICATIONS/TOPPBase.h>

using namespace OpenMS;
using namespace std;

//-------------------------------------------------------------
//Doxygen docu
//-------------------------------------------------------------

/**
	@page TOPP_MapAligner MapAligner

	@brief Corrects retention time distortions between maps.

<CENTER>
	<table>
		<tr>
			<td ALIGN = "center" BGCOLOR="#EBEBEB"> potential predecessor tools </td>
			<td VALIGN="middle" ROWSPAN=3> \f$ \longrightarrow \f$ MapAligner \f$ \longrightarrow \f$</td>
			<td ALIGN = "center" BGCOLOR="#EBEBEB"> potential successor tools </td>
		</tr>
		<tr>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=1> @ref TOPP_FeatureFinder </td>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=2> @ref TOPP_FeatureLinker </td>
		</tr>
		<tr>
			<td VALIGN="middle" ALIGN = "center" ROWSPAN=1> @ref TOPP_IDMapper </td>
		</tr>
	</table>
</CENTER>


	This tool provides several different algorithms to align the retention time scales of multiple input files, correcting shifts and distortions. (Click on the links to get detailed documentation for each algorithm. Scroll down for the parameter description.)

	- @ref OpenMS::MapAlignmentAlgorithmPoseClustering "pose_clustering": The pose clustering algorithm as described in doi:10.1093/bioinformatics/btm209 is used to find an affine transformation, which is further refined by a feature grouping step. This algorithm can be applied to features (featureXML) and peaks (mzML), but it has mostly been developed and tested on features.
	- @ref OpenMS::MapAlignmentAlgorithmIdentification "identification": An alignment algorithm based on peptide identifications, and thus applicable to files containing peptide IDs (idXML, annotated featureXML/consensusXML). It finds peptide sequences that different input files have in common and uses them as points of correspondence between the inputs.
	- @ref OpenMS::MapAlignmentAlgorithmApplyGivenTrafo "apply_given_trafo": Applies transformations that are read from the files provided with the option @p trafo_in. These transformations might have been generated by a previous invocation of MapAligner, see the option @p trafo_out.  However, the trafoXML file format is not very complicated, so it is relatively easy to write (or generate) your own files.  This algorithm can be applied to mzML, featureXML, consensusXML, and idXML data.
	- @ref OpenMS::MapAlignmentAlgorithmSpectrumAlignment "spectrum_alignment": An experimental algorithm based on spectrum alignment; applicable only to peak maps (mzML).

	In OpenMS 1.8, the extraction of data for the alignment (performed by the algorithms listed above) has been separated from the modelling of RT transformations based on that data. It is now possible to use different models independently of the chosen algorithm - see the @p model section of the parameters. To use the same model type and model parameters previously fixed to an algorithm, set "model:type" to "default". The different available models are:
	- @ref OpenMS::TransformationModelLinear "linear": Linear model.
	- @ref OpenMS::TransformationModelBSpline "b_spline": Smoothing spline (non-linear).
	- @ref OpenMS::TransformationModelInterpolated "interpolated": Different types of interpolation.


	<B>The command line parameters of this tool are:</B>
	@verbinclude TOPP_MapAligner.cli

*/

// We do not want this class to show up in the docu:
/// @cond TOPPCLASSES

class TOPPMapAligner
  : public TOPPBase
{

public:
	TOPPMapAligner()
		: TOPPBase("MapAligner","Corrects retention time distortions between maps.")
	{
	}

protected:
	void registerOptionsAndFlags_()
	{
		String formats = "mzML,featureXML,consensusXML,idXML";
		registerInputFileList_("in", "<files>", StringList(), "Input files separated by blanks", true);
		setValidFormats_("in", StringList::create(formats));
		registerOutputFileList_("out", "<files>", StringList(), "Output files separated by blanks", false);
		setValidFormats_("out", StringList::create(formats));
		registerOutputFileList_("trafo_out", "<files>", StringList(), "Transformation output files separated by blanks", false);
		setValidFormats_("trafo_out", StringList::create("trafoXML"));
		registerStringOption_("type", "<name>", "", "Map alignment algorithm type", true);
    setValidStrings_("type", ToolHandler::getTypes(toolName_()));
		// TODO  Remove this hack when StringList becomes available in INIFileEditor. Transformations should be specified in algorithm section.
		registerInputFileList_("trafo_in", "<files>", StringList(), "Only for 'apply_given_trafo' algorithm: Transformations to apply.", false);
		setValidFormats_("trafo_in", StringList::create("trafoXML"));
		registerFlag_("invert", "Only for 'apply_given_trafo' algorithm: Invert transformations (approximatively) before applying them.");
		addEmptyLine_();
		addText_("Either 'out' or 'trafo_out' has to be provided. They can be used together.");

		registerTOPPSubsection_("reference", "Options to define a reference file (currently only supported by the algorithms 'identification' and 'pose_clustering_affine')");
		registerInputFile_("reference:file", "<file>", "", "File to use as reference (for the 'pose_clustering_affine' algorithm, same file format as input files required)\n", false);
		setValidFormats_("reference:file", StringList::create(formats));
		registerIntOption_("reference:index", "<number>", 0, "Use one of the input files as reference ('1' for the first file, etc.).\nIf '0', no explicit reference is set, but the selected algorithm may pick one if needed.", false);
		setMinInt_("reference:index", 0);

		registerTOPPSubsection_("model", "Options to control the modelling of retention time transformations from data");
		registerStringOption_("model:type", "<name>", "default", "Type of model ('default' depends on the selected algorithm and also sets the model parameters below!)", false);
		StringList model_types;
		TransformationDescription::getModelTypes(model_types);
		model_types.insert(model_types.begin(), "default");
		setValidStrings_("model:type", model_types);
		registerFlag_("model:symmetric_regression", "Only for 'linear' model: Perform linear regression on 'y - x' vs. 'y + x', instead of on 'y' vs. 'x'.");
		registerIntOption_("model:num_breakpoints", "<number>", 5, "Only for 'b_spline' model: Number of breakpoints of the cubic spline in the smoothing step. The breakpoints are spaced uniformly on the retention time interval. More breakpoints mean less smoothing. Reduce this number if the transformation has an unexpected shape.", false);
		setMinInt_("model:num_breakpoints", 2);
		registerStringOption_("model:interpolation_type", "<name>", "linear", "Only for 'interpolated' model: Type of interpolation to apply.", false);
		StringList interpolation_types;
		TransformationModelInterpolated::getInterpolationTypes(interpolation_types);
		// "polynomial" interpolation is not suitable for RT data, so remove it:
		StringList::Iterator pos = find(interpolation_types.begin(), 
																		interpolation_types.end(), "polynomial"); 
		interpolation_types.erase(pos); 
		setValidStrings_("model:interpolation_type", interpolation_types);

    addEmptyLine_();
		addText_("This tool takes a number of input files, aligns them and writes the results to the output files.");

		registerSubsection_("algorithm","Algorithm parameters section");
	}

	Param getSubsectionDefaults_(const String& /* section */ ) const
	{
		String type = getStringOption_("type");
		MapAlignmentAlgorithm* algo = Factory<MapAlignmentAlgorithm>::create(type);
		Param tmp = algo->getParameters();

		// TODO  Remove this hack when StringList when become available in INIFileEditor.
		if (type == "apply_given_trafo")
		{
			tmp.setValue("transformations", getStringList_("trafo_in"));
			tmp.setValue("invert", getFlag_("invert") ? "true" : "false");
		}

		delete algo;
		return tmp;
	}

	ExitCodes main_(int, const char**)
	{
		//-------------------------------------------------------------
		// parameter handling
		//-------------------------------------------------------------
		StringList ins = getStringList_("in");
		StringList outs = getStringList_("out");
		StringList trafos = getStringList_("trafo_out");
		String type = getStringOption_("type");
		String model_type = getStringOption_("model:type");
		Param model_params = getParam_().copy("model:", true);

		ProgressLogger progresslogger;
		progresslogger.setLogType(log_type_);

		//-------------------------------------------------------------
		// check for valid input
		//-------------------------------------------------------------
		// check whether some kind of output file is given:
		if (outs.empty() && trafos.empty())
		{
			writeLog_("Error: Either data output or transformation output files have to be provided!");
			return ILLEGAL_PARAMETERS;
		}
		// check whether number of input files equals number of output files:
		if (!outs.empty() && (ins.size() != outs.size()))
		{
			writeLog_("Error: The number of input and output files has to be equal!");
			return ILLEGAL_PARAMETERS;
		}
		if (!trafos.empty() && (ins.size() != trafos.size()))
		{
			writeLog_("Error: The number of input and transformation output files has to be equal!");
			return ILLEGAL_PARAMETERS;
		}
		// check whether all input files have the same type (this type is used to store the output type too):
		FileTypes::Type in_type = FileHandler::getType(ins[0]);
		for (Size i = 1; i < ins.size(); ++i)
		{
			if (FileHandler::getType(ins[i]) != in_type)
			{
				writeLog_("Error: All input files have to be in the same format!");
				return ILLEGAL_PARAMETERS;
			}
		}
		// check reference parameters:
		Size reference_index = getIntOption_("reference:index");
		String reference_file = getStringOption_("reference:file");
		if (reference_index && !reference_file.empty())
		{
			writeLog_("Error: 'reference:index' and 'reference:file' cannot be used together");
			return ILLEGAL_PARAMETERS;
		}
		if (reference_index > ins.size())
		{
			writeLog_("Error: 'reference:index' must not be higher than the number of input files");
			return ILLEGAL_PARAMETERS;
		}

    //-------------------------------------------------------------
    // set up alignment algorithm
    //-------------------------------------------------------------
    MapAlignmentAlgorithm* alignment = Factory<MapAlignmentAlgorithm>::create(type);
		Param alignment_param = getParam_().copy("algorithm:", true);

		// TODO  Remove this hack when StringList when become available in INIFileEditor.
		if (type == "apply_given_trafo")
		{
			alignment_param.setValue("transformations", getStringList_("trafo_in"));
		}

		writeDebug_("Used alignment parameters", alignment_param, 3);
		alignment->setParameters(alignment_param);
		alignment->setLogType(log_type_);

		// pass the reference parameters on to the algorithm:
		alignment->setReference(reference_index, reference_file);

		// get parameters for the model:
		if (model_type == "default")
		{
			alignment->getDefaultModel(model_type, model_params);
		}

		std::vector<TransformationDescription> transformations;

    //-------------------------------------------------------------
    // perform peak alignment
    //-------------------------------------------------------------
		if (in_type == FileTypes::MZML)
		{
			// load input
			std::vector< MSExperiment<> > peak_maps(ins.size());
			MzMLFile f;
			f.setLogType(log_type_);
			for (Size i = 0; i < ins.size(); ++i)
			{
		    f.load(ins[i], peak_maps[i]);
			}

			// try to align
			try
			{
				alignment->alignPeakMaps(peak_maps, transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for peak data!");
				return INTERNAL_ERROR;
			}
			if (model_type != "none")
			{
				alignment->fitModel(model_type, model_params, transformations);
			}
			alignment->transformPeakMaps(peak_maps, transformations);

			// write output
			progresslogger.startProgress(0, outs.size(), "writing output files");
			for (Size i = 0; i < outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(peak_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], peak_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform feature alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::FEATUREXML)
		{
			// load input
			std::vector< FeatureMap<> > feat_maps(ins.size());
			FeatureXMLFile f;
			// f.setLogType(log_type_); // TODO
			progresslogger.startProgress(0, ins.size(), "loading input files");
			for (Size i = 0; i < ins.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.load(ins[i], feat_maps[i]);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignFeatureMaps(feat_maps, transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for feature data!");
				return INTERNAL_ERROR;
			}
			if (model_type != "none")
			{
				alignment->fitModel(model_type, model_params, transformations);
			}
			alignment->transformFeatureMaps(feat_maps, transformations);

			// write output
			progresslogger.startProgress(0, outs.size(), "writing output files");
			for (Size i = 0; i < outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(feat_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], feat_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform consensus alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::CONSENSUSXML)
		{
			// load input
			std::vector<ConsensusMap> cons_maps(ins.size());
			ConsensusXMLFile f;
			// f.setLogType(log_type_); // TODO
			progresslogger.startProgress(0, ins.size(), "loading input files");
			for (Size i = 0; i < ins.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.load(ins[i], cons_maps[i]);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignConsensusMaps(cons_maps, transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for consensus feature data!");
				return INTERNAL_ERROR;
			}
			if (model_type != "none")
			{
				alignment->fitModel(model_type, model_params, transformations);
			}
			alignment->transformConsensusMaps(cons_maps, transformations);

			// write output
			progresslogger.startProgress(0, outs.size(), "writing output files");
			for (Size i = 0; i < outs.size(); ++i)
			{
				progresslogger.setProgress(i);
				
				//annotate output with data processing info
				addDataProcessing_(cons_maps[i], getProcessingInfo_(DataProcessing::ALIGNMENT));

		    f.store(outs[i], cons_maps[i]);
			}
			progresslogger.endProgress();
		}
    //-------------------------------------------------------------
    // perform peptide alignment
    //-------------------------------------------------------------
		else if (in_type == FileTypes::IDXML)
		{
			// load input
			std::vector< std::vector<ProteinIdentification> > protein_ids_vec(ins.size());
			std::vector< std::vector<PeptideIdentification> > peptide_ids_vec(ins.size());

			IdXMLFile f;
			// f.setLogType_(log_type_);

			progresslogger.startProgress(0, ins.size(), "loading input files");
			for (Size i = 0; i < ins.size(); ++i)
			{
				progresslogger.setProgress(i);
				String document_id;
		    f.load( ins[i], protein_ids_vec[i], peptide_ids_vec[i], document_id);
			}
			progresslogger.endProgress();

			// try to align
			try
			{
				alignment->alignPeptideIdentifications(peptide_ids_vec, transformations);
			}
			catch (Exception::NotImplemented&)
			{
				writeLog_("Error: The algorithm '" + type + "' cannot be used for peptide data!");
				return INTERNAL_ERROR;
			}
			if (model_type != "none")
			{
				alignment->fitModel(model_type, model_params, transformations);
			}
			alignment->transformPeptideIdentifications(peptide_ids_vec, 
																								 transformations);

			// write output
			progresslogger.startProgress(0, outs.size(), "writing output files");
			for (Size i = 0; i < outs.size(); ++i)
			{
				progresslogger.setProgress(i);
		    f.store(outs[i], protein_ids_vec[i], peptide_ids_vec[i]);
			}
			progresslogger.endProgress();
		}
		else
		{
			// TODO can this really happen? I think it is tested above. Otherwise
			// throw an appropriate exception?
			return ILLEGAL_PARAMETERS;
		}

		delete alignment;

		if (trafos.size() != 0)
		{
			for (Size i = 0; i < transformations.size(); ++i)
			{
				TransformationXMLFile().store(trafos[i], transformations[i]);
			}
		}

		return EXECUTION_OK;
	}
};


int main( int argc, const char** argv )
{
  TOPPMapAligner tool;
  return tool.main(argc,argv);
}

/// @endcond
