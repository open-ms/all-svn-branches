// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2007 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#include <OpenMS/APPLICATIONS/TOPPViewBase.h>

#ifdef DB_DEF
#include <OpenMS/FORMAT/DB/DBConnection.h>
#include <OpenMS/FORMAT/DB/DBAdapter.h>
#include <OpenMS/VISUAL/DIALOGS/DBSpectrumSelectorDialog.h>
#endif

#ifdef CGAL_DEF
#include <OpenMS/TRANSFORMATIONS/FEATUREFINDER/FeatureFinder.h>
#include <OpenMS/VISUAL/DIALOGS/FeaFiDialog.h>
#endif

#include <OpenMS/VISUAL/DIALOGS/SaveImageDialog.h>
#include <OpenMS/VISUAL/DIALOGS/TOPPViewBasePDP.h>
#include <OpenMS/VISUAL/Spectrum1DWidget.h>
#include <OpenMS/VISUAL/Spectrum1DCanvas.h>
#include <OpenMS/VISUAL/Spectrum2DCanvas.h>
#include <OpenMS/VISUAL/Spectrum2DWidget.h>
#include <OpenMS/VISUAL/MultiGradientSelector.h>
#include <OpenMS/VISUAL/Spectrum1DWindow.h>
#include <OpenMS/VISUAL/Spectrum2DWindow.h>
#include <OpenMS/VISUAL/Spectrum3DWindow.h>
#include <OpenMS/VISUAL/Spectrum3DOpenGLCanvas.h>
#include <OpenMS/FORMAT/FileHandler.h>
#include <OpenMS/FORMAT/DFeatureMapFile.h>
#include <OpenMS/TRANSFORMATIONS/RAW2PEAK/PeakPickerCWT.h>
#include <OpenMS/VISUAL/DIALOGS/PeakPickingDialog.h>
#include <OpenMS/FILTERING/TRANSFORMERS/LinearResampler.h>
#include <OpenMS/FILTERING/SMOOTHING/SavitzkyGolaySVDFilter.h>
#include <OpenMS/FILTERING/SMOOTHING/GaussFilter.h>
#include <OpenMS/VISUAL/DIALOGS/SmoothingDialog.h>
#include <OpenMS/FILTERING/BASELINE/TopHatFilter.h>
#include <OpenMS/VISUAL/DIALOGS/BaselineFilteringDialog.h>
#include <OpenMS/KERNEL/MSExperiment.h>
#include <OpenMS/VISUAL/Spectrum3DCanvas.h>
#include <OpenMS/SYSTEM/File.h>
#include <OpenMS/VISUAL/MSMetaDataExplorer.h>
#include <OpenMS/FORMAT/DFeaturePairsFile.h>

// Qt
#include <qaction.h>
#include <q3mainwindow.h>
#include <qtoolbutton.h>
#include <qworkspace.h>
#include <q3filedialog.h>
#include <qapplication.h>
#include <qprinter.h>
#include <qpainter.h>
#include <q3paintdevicemetrics.h>
#include <qmessagebox.h>
#include <qlabel.h>
#include <qtooltip.h>
#include <qinputdialog.h>
#include <qstring.h>
#include <qlineedit.h>
#include <qdir.h>
#include <q3popupmenu.h>
#include <qmenubar.h>
#include <qstatusbar.h>
#include <qimage.h>
#include <qlayout.h>
#include <q3listview.h>
#include <q3header.h>
#include <QSqlQuery>
#include <QPixmap>
#include <QCloseEvent>
#include <Q3VBoxLayout>
#include <Q3Frame>
#include <Q3ActionGroup>

// STL
#include <iostream>
#include <sstream>

//action modes
#include "../VISUAL/ICONS/zoom.xpm"
#include "../VISUAL/ICONS/translate.xpm"
#include "../VISUAL/ICONS/select.xpm"
#include "../VISUAL/ICONS/measure.xpm"

//intensity modes
#include "../VISUAL/ICONS/lin.xpm"
#include "../VISUAL/ICONS/log.xpm"
#include "../VISUAL/ICONS/percentage.xpm"
#include "../VISUAL/ICONS/snap.xpm"

//common
#include "../VISUAL/ICONS/grid.xpm"
#include "../VISUAL/ICONS/print.xpm"
#include "../VISUAL/ICONS/reset_zoom.xpm"
#include "../VISUAL/ICONS/tile_horizontal.xpm"
#include "../VISUAL/ICONS/tile_vertical.xpm"

//1d
#include "../VISUAL/ICONS/lines.xpm"
#include "../VISUAL/ICONS/peaks.xpm"

//2d
#include "../VISUAL/ICONS/points.xpm"
#include "../VISUAL/ICONS/colors.xpm"
#include "../VISUAL/ICONS/contours.xpm"



using namespace std;

namespace OpenMS
{
  using namespace Internal;
	using namespace Math;
	
  TOPPViewBase* TOPPViewBase::instance_ = 0;

  TOPPViewBase* TOPPViewBase::instance()
  {
    if (!instance_)
    {
      instance_ = new TOPPViewBase();
    }
    return instance_;
  }

  TOPPViewBase::TOPPViewBase(QWidget* parent, const char* name, Qt::WindowFlags f):
      Q3MainWindow(parent,name,f),

      PreferencesManager(),
      recent_files_()
  {
    //prevents errors caused by too small width,height values
    setMinimumSize(200,200);

    // create dummy widget (to be able to have a layout), Tab bar and workspace
    QWidget* dummy = new QWidget(this);
    setCentralWidget(dummy);
    Q3VBoxLayout* box_layout = new Q3VBoxLayout(dummy);
    tab_bar_ = new EnhancedTabBar(dummy);
    tab_bar_->addTab("dummy");
    tab_bar_->setMinimumSize(tab_bar_->sizeHint());
    tab_bar_->removeTab(0);

    //connect slots and sigals for selecting spectra
    connect(tab_bar_,SIGNAL(selected(int)),this,SLOT(focusByTab(int)));
    connect(tab_bar_,SIGNAL(doubleClicked(int)),this,SLOT(closeFileByTab(int)));

    box_layout->addWidget(tab_bar_);
    ws_=new QWorkspace(dummy);
    connect(ws_,SIGNAL(windowActivated(QWidget*)),this,SLOT(updateToolbar(QWidget*)));
    connect(ws_,SIGNAL(windowActivated(QWidget*)),this,SLOT(updateTabBar(QWidget*)));
    connect(ws_,SIGNAL(windowActivated(QWidget*)),this,SLOT(updateLayerbar()));
    box_layout->addWidget(ws_);

    // File menu
    Q3PopupMenu * file = new Q3PopupMenu(this);
    menuBar()->insertItem("&File", file);
    file->insertItem("&Open",this,SLOT(openSpectrumDialog()));
    file->insertItem("&Close",this,SLOT(closeFile()));
    file->insertSeparator();
    recent_menu_ = new Q3PopupMenu(this);
    file->insertItem("Recent files",recent_menu_);
    file->insertSeparator();
    file->insertItem("&Preferences",this, SLOT(preferencesDialog()));
    file->insertItem("&Quit",qApp,SLOT(quit()));
    
    //Layer menu
    Q3PopupMenu * layer = new Q3PopupMenu(this);
    menuBar()->insertItem("&Layer", layer);
    layer->insertItem("&Save visible data",this,SLOT(saveLayer()));
    layer->insertItem("&Edit metadata",this,SLOT(editMetadata()));
    layer->insertItem("&Intensity distribution",this,SLOT(layerIntensityDistribution()));
		layer->insertSeparator();
    layer->insertItem("&Preferences",this, SLOT(layerPreferencesDialog()));
    
    //View menu
    Q3PopupMenu * view = new Q3PopupMenu(this);
    menuBar()->insertItem("&View", view);
    view->insertItem("&Go to",this,SLOT(gotoDialog()), Qt::CTRL+Qt::Key_G);
   	view->insertItem("Show/Hide axis legends",this,SLOT(changeAxisVisibility()));
   	
    //Image menu
    Q3PopupMenu * image = new Q3PopupMenu(this);
    menuBar()->insertItem("&Image", image);
    image->insertItem("&Save to file",this,SLOT(saveImage()));
    image->insertItem("&Print",this,SLOT(print()));

    //Windows menu
    Q3PopupMenu * windows = new Q3PopupMenu(this);
    menuBar()->insertItem("&Windows", windows);
    windows->insertItem("&Cascade",this->ws_,SLOT(cascade()));
    windows->insertItem("&Tile automatic",this->ws_,SLOT(tile()));
    windows->insertItem(QIcon(QPixmap(XPM_tile_h)),"Tile &vertical",this,SLOT(tileHorizontal()));
    windows->insertItem(QIcon(QPixmap(XPM_tile_v)),"Tile &horizontal",this,SLOT(tileVertical()));
    
    //Tools menu
    tools_menu_ = new Q3PopupMenu(this);
    menuBar()->insertItem("&Tools", tools_menu_);
    tools_menu_->insertItem("&Show Selected Peaks (1D)", this, SLOT(showPeaklistActiveSpectrum()));
    tools_menu_->insertItem("&Pick Peaks", this, SLOT(pickActiveSpectrum()));
    tools_menu_->insertItem("&Smooth data", this, SLOT(smoothActiveSpectrum()));
    tools_menu_->insertItem("&Filter baseline in data", this, SLOT(baselineFilteringActiveSpectrum()));
    tools_menu_->insertItem("&Find Features (2D)", this, SLOT(findFeaturesActiveSpectrum()));

    //create status bar
    message_label_ = new QLabel(statusBar());
    statusBar()->addWidget(message_label_,1);

    rt_label_ = new QLabel("RT: 12345678", statusBar());
    rt_label_->setMinimumSize(rt_label_->sizeHint());
    rt_label_->setText("");
    statusBar()->addWidget(rt_label_,0,true);
    mz_label_ = new QLabel("m/z: 12345678", statusBar());
    mz_label_->setMinimumSize(mz_label_->sizeHint());
    mz_label_->setText("");
    statusBar()->addWidget(mz_label_,0,true);
    int_label_ = new QLabel("Int: 123456789012", statusBar());
    int_label_->setMinimumSize(int_label_->sizeHint());
    int_label_->setText("");
    statusBar()->addWidget(int_label_,0,true);

    //create toolbars and connect signals
    createToolBar_();

    //layer bar (for managing several Spectra in a 1D-Window)
    layer_bar_ = new Q3ToolBar(this,"layerbar");
    layer_bar_->setLabel( "Layer manager" );
    layer_bar_->setFrameStyle( QFrame::StyledPanel | Q3Frame::Plain );
    layer_bar_->setLineWidth( 1 );
    layer_bar_->setResizeEnabled(true);
    moveDockWindow(layer_bar_,Qt::DockRight);
    setDockEnabled(layer_bar_,Qt::DockTop,false);
    setDockEnabled(layer_bar_,Qt::DockBottom,false);

    //add Layer Manager and connect signals
    layer_manager_ = new Q3ListView(layer_bar_, "LayerManager");
		layer_manager_->setSizePolicy(QSizePolicy::QSizePolicy::Preferred,QSizePolicy::Minimum);
		layer_manager_->addColumn("Layer");
		layer_manager_->setSorting(-1);
		layer_manager_->setHScrollBarMode(Q3ScrollView::AlwaysOff);
		layer_manager_->header()->hide();
    layer_bar_->hide();
    connect(layer_manager_,SIGNAL(selectionChanged()),this,SLOT(layerSelectionChange()));
		connect(layer_manager_,SIGNAL(contextMenuRequested(Q3ListViewItem* ,const QPoint&, int)),this,SLOT(layerContextMenu(Q3ListViewItem*, const QPoint&, int)));
		connect(layer_manager_,SIGNAL(clicked(Q3ListViewItem*, const QPoint&, int)),this,SLOT(layerVisibilityChange(Q3ListViewItem*, const QPoint&, int)));
		
    //register meta value names
    MetaInfo::registry().registerName("FeatureDrawMode", "Specify what to draw of the Feature: BoundingBox, ConvexHulls");

    //set preferences file name + load preferencs
    loadPreferences();
  }

  void TOPPViewBase::addDBSpectrum(UnsignedInt db_id, bool as_new_window, bool maps_as_2d, bool maximize, OpenDialog::Mower use_mower)
  {
#ifdef DB_DEF
    //DBConnection for all DB queries
    DBConnection con;
    con.connect(getPref("Preferences:DB:Name"), getPref("Preferences:DB:Login"),getPref("DBPassword"),getPref("Preferences:DB:Host"),getPrefAsInt("Preferences:DB:Port"));

    //DB adapter
    DBAdapter dba(con);

    String db_id_string(db_id);
    QSqlQuery result;
    con.executeQuery("SELECT count(id) from DATA_Spectrum where fid_MSExperiment='"+db_id_string+"' and MSLevel='1'",result);

    //tab caption
    String caption = "DB ("+db_id_string+")";

    SpectrumWindow* w;

    SpectrumCanvas::ExperimentType* exp = 0;

    if (activeWindow_()==0)
    {
      as_new_window = true;
    }

    //open in new window
    if (as_new_window)
    {
      //create 1D View
      if (result.value(0).toInt()==1)
      {
      	//cout << "NEW 1D" << endl;
        // create 1D window
        w = new Spectrum1DWindow(ws_,Qt::WDestructiveClose);

        //determine Spectrum id
        con.executeQuery("SELECT id from DATA_Spectrum where fid_MSExperiment='"+db_id_string+"' and MSLevel='1'",result);
        UID spectrum_id = result.value(0).toInt();

        //load data
        exp = &(w->widget()->canvas()->addEmptyPeakLayer());
        exp->resize(1);
        dba.loadSpectrum(spectrum_id,(*exp)[0]);
      }
      //create 2D/3D view
      else
      {
        //create 2D view
        if (maps_as_2d)
        {
          //cout << "NEW 2D" << endl;
          //create 2D window
          w = new Spectrum2DWindow(ws_,Qt::WDestructiveClose);

          //load spectrum
          exp = &(w->widget()->canvas()->addEmptyPeakLayer());
          dba.loadExperiment(db_id, (*exp));
        }
        //create 3D view
        else
        {
          //cout << "NEW 3D" << endl;
        	// create 3D window
          w = new Spectrum3DWindow(ws_, Qt::WDestructiveClose);

          //load data
          exp = &(w->widget()->canvas()->addEmptyPeakLayer());
          dba.loadExperiment(db_id, *exp);
        }
      }
      w->setMainPreferences(prefs_);
    }
    //open in active window
    else
    {
      //create 1D View
      if (result.value(0).toInt()==1)
      {
      	//cout << "ACTIVE 1D" << endl;
        w = active1DWindow_();
        //wrong active window type
        if (w==0)
        {
          QMessageBox::warning(this,"Wrong file type",("You cannot open 1D data ("+db_id_string+") in a 2D window!<BR>Please open the file in new tab.").c_str());
          return;
        }
        else //open it
        {
          //determine Spectrum id
          con.executeQuery("SELECT id from DATA_Spectrum where fid_MSExperiment='"+db_id_string+"' and MSLevel='1'", result);
          UID spectrum_id = result.value(0).toInt();

          //load data
	        exp = &(w->widget()->canvas()->addEmptyPeakLayer());
	        exp->resize(1);
	        dba.loadSpectrum(spectrum_id,(*exp)[0]);
        }
      }
      //create 2D/3D view
      else
      {
        Spectrum2DWindow* w2 = active2DWindow_();
        Spectrum3DWindow* w3 = active3DWindow_();
        //wrong active window type
        if (w2==0 && w3==0)
        {
          QMessageBox::warning(this,"Wrong file type",("You cannot open 1D data ("+db_id_string+") in a 2D/3D window!<BR>Please open the file in new tab.").c_str());
          return;
        }
        //create 2D view
        if (w2!=0)
        {
        	//cout << "ACTIVE 2D" << endl;
          w = w2;

          //load data
          exp = &(w->widget()->canvas()->addEmptyPeakLayer());
          dba.loadExperiment(db_id, (*exp));
        }
        //create 3D view
        else
        {
        	//cout << "ACTIVE 3D" << endl;
          w = w3;

          //load data
          exp = &(w->widget()->canvas()->addEmptyPeakLayer());
          dba.loadExperiment(db_id, (*exp));
        }
      }
		}
		
    //noise estimator
    float cutoff = 0;
    if(use_mower!=OpenDialog::NO_MOWER && exp->size()>1)
    {
      cutoff = estimateNoise_(*exp);
      cout << "Estimated noise level: " << cutoff << endl;
    }
    w->widget()->canvas()->finishAdding(cutoff);
		w->widget()->canvas()->setCurrentLayerName(caption);
    //use_mower

    //do for all windows
    if (as_new_window)
    {
      connectWindowSignals_(w);
      w->setCaption(caption.c_str());
      addClient(w,caption);
      addTab_(w,caption);
    }

    //do for all (in active and in new window, 1D/2D/3D)
    if(maximize)
    {
      w->showMaximized();
    }

    //do for all windows
    updateLayerbar();
#endif
  }

  float TOPPViewBase::estimateNoise_(const SpectrumCanvas::ExperimentType& exp)
  {
    float noise = 0.0;
    UnsignedInt count = 0;
    srand(time(0));
    //cout << "size: " << exp.size() << endl;
    while (count<10)
    {
      UnsignedInt scan = (UnsignedInt)( (double)rand() / ((double)(RAND_MAX)+1.0f) * (double)(exp.size()-1) );

      if (scan < exp.size() && exp[scan].getMSLevel()==1)
      {
        vector<float> tmp;
        tmp.reserve(exp[scan].size());
        for(SpectrumCanvas::ExperimentType::SpectrumType::ConstIterator it = exp[scan].begin()
            ; it != exp[scan].end()
            ; ++it)
        {
          tmp.push_back(it->getIntensity());
        }
        std::sort(tmp.begin(),tmp.end());
        //cout << "scan: "<< scan <<" Groesse: " << tmp.size() << " Index: " << (UnsignedInt)ceil((float)(tmp.size()-1)/1.25f) << " Wert: "<< tmp[(UnsignedInt)ceil((float)(tmp.size()-1)/1.25f)] << endl;
        noise += tmp[(UnsignedInt)ceil((float)(tmp.size()-1)/1.25f)];

        ++count;
      }
    }
    noise = noise / 10.0f;
    return noise;
  }

  void TOPPViewBase::preferencesDialog()
  {
    setActive(true);
    if (showPreferencesDialog())
    {
      savePreferences();
    }
  }

  void TOPPViewBase::addSpectrum(const String& filename,bool as_new_window, bool maps_as_2d, bool maximize, OpenDialog::Mower use_mower, FileHandler::Type force_type)
  {
    if (!File::exists(filename))
    {
      QMessageBox::warning(this,"Open file error",("The file '"+filename+"' does not exist!").c_str());
      return;
    }

    //extract the filename without path
    String caption = File::basename(filename);

    //update recent files list
    addRecentFile_(filename);

    //windowpointer
    SpectrumWindow* w=0;
    
    if (activeWindow_()==0)
    {
      as_new_window = true;
    }

		//determine file type if not forced
		FileHandler fh;
		if (force_type==FileHandler::UNKNOWN)
		{
			if (force_type==FileHandler::UNKNOWN)
			{
				force_type = fh.getTypeByFileName(filename);
			}

			if (force_type==FileHandler::UNKNOWN)
			{
				force_type = fh.getTypeByContent(filename);
			}
		}

		if (force_type==FileHandler::UNKNOWN)
		{
      QMessageBox::warning(this,"Open file error",("Could not determine file type of '"+filename+"'!").c_str());
      return;
		}

    if (as_new_window)
    {
      if (force_type==FileHandler::DTA)
      {
        w = new Spectrum1DWindow(ws_,Qt::WDestructiveClose);
      }
      else if (maps_as_2d || force_type==FileHandler::FEATURE || force_type==FileHandler::FEATURE_PAIRS) //2d or features
      {
        w = new Spectrum2DWindow(ws_,Qt::WDestructiveClose);
      }
      else //3d
      {
        w = new Spectrum3DWindow(ws_,Qt::WDestructiveClose);
      }

      //set main preferences
      w->setMainPreferences(prefs_);
    }
    else //!as_new_window
    {
      if (active1DWindow_()!=0) //1D window
      {
        if (force_type!=FileHandler::DTA)
        {
          QMessageBox::warning(this,"Wrong file type",("You cannot open 2D data ("+filename+") in a 1D window!").c_str());
          return;
        }

        w = active1DWindow_();
      }
      else if (active2DWindow_()!=0) //2d window
      {
        if (force_type==FileHandler::DTA)
        {
          QMessageBox::warning(this,"Wrong file type",("You cannot open 1D data ("+filename+") in a 2D window!").c_str());
          return;
        }
        w = active2DWindow_();
      }
      else if (active3DWindow_()!=0)//3d window
      {
        if (force_type==FileHandler::DTA)
        {
          QMessageBox::warning(this,"Wrong file type",("You cannot open 1D data ("+filename+") in a 3D window!").c_str());
          return;
        }
        w = active3DWindow_();
      }
    }

    //try to read the data from file
    if (force_type==FileHandler::FEATURE) //features
    {
      DFeatureMap<2> map;
      try
      {
        DFeatureMapFile().load(filename,map);
      }
      catch(Exception::Base& e)
      {
        QMessageBox::warning(this,"Error",(String("Error while reading feature file: ")+e.what()).c_str());
        return;
      }
      w->widget()->canvas()->addLayer(map,false);
      w->widget()->canvas()->setCurrentLayerName(caption);
    }
    else if (force_type==FileHandler::FEATURE_PAIRS) //feature pairs
    {
    	//load pairs
      DFeaturePairVector<2> pairs;
      try
      {
        DFeaturePairsFile().load(filename,pairs);
      }
      catch(Exception::Base& e)
      {
        QMessageBox::warning(this,"Error",(String("Error while reading feature pairs file: ")+e.what()).c_str());
        return;
      }
      
      //convert to features
      DFeatureMap<2> map;
      DFeaturePairsFile::pairsToFeatures(pairs,map);
      w->widget()->canvas()->addLayer(map,true);
      w->widget()->canvas()->setCurrentLayerName(caption);
    }
    else
    {
      //try to read the data from file (raw/peak data)
      SpectrumCanvas::ExperimentType* exp = &(w->widget()->canvas()->addEmptyPeakLayer());
      try
      {
        fh.loadExperiment(filename,*exp, force_type);
      }
      catch(Exception::Base& e)
      {
        QMessageBox::warning(this,"Error",(String("Error while reading data file: ")+e.what()).c_str());
        return;
      }

      //check if only one scan is in a 2d file
      if (as_new_window && active1DWindow_()==0 && exp->size()==1)
      {
        delete(w);
        w = new Spectrum1DWindow(ws_,Qt::WDestructiveClose);
        w->setMainPreferences(prefs_);
        exp = &(w->widget()->canvas()->addEmptyPeakLayer());
        FileHandler().loadExperiment(filename,*exp, force_type);
      }

      //do for all (in active and in new window, 1D/2D/3D)
      float cutoff=0;

      //calculate noise
      if(use_mower!=OpenDialog::NO_MOWER && exp->size()>1)
      {
        cutoff = estimateNoise_(*exp);
      }
      w->widget()->canvas()->finishAdding(cutoff);
      w->widget()->canvas()->setCurrentLayerName(caption);
    }
  	updateLayerbar();

    if (as_new_window)
    {
    	ws_->addWindow(w);
      connectWindowSignals_(w);
      w->setCaption(filename.c_str());
      addClient(w,filename);
      addTab_(w,caption);
    }
    if(maximize)
    {
      w->showMaximized();
    }
  }

  void TOPPViewBase::addRecentFile_(const String& filename)
  {
    //get number of files in list from settings
    UnsignedInt number_of_recent_files_ = UnsignedInt(prefs_.getValue("Preferences:NumberOfRecentFiles"));
    String tmp = filename;

    //add prefix to relative paths
    if (!tmp.hasPrefix("/"))
    {
      tmp = QDir::currentDirPath().ascii()+string("/")+ tmp;
    }

    //check if the file is already in the vector. if so remove it
    recent_files_.erase(remove
                        (recent_files_.begin(),recent_files_.end(),tmp),recent_files_.end());

    //add the file to the front
    recent_files_.insert(recent_files_.begin(),tmp);

    //shrink the recent_files to 10
    if (recent_files_.size()>number_of_recent_files_)
    {
      recent_files_.resize(number_of_recent_files_);
    }

    //update recent file menu
    updateRecentMenu_();
  }

  void TOPPViewBase::updateRecentMenu_()
  {
    //update recent file menu
    recent_menu_->clear();
    for (UnsignedInt i=0; i<recent_files_.size(); ++i)
    {
      recent_menu_->insertItem(recent_files_[i].c_str(),this,SLOT(openRecentFile(int)),0,i);
    }
  }


  void TOPPViewBase::addTab_(SpectrumWindow* w, const String& tabCaption)
  {
    //add to tab bar (map the address of the widget and the pointer)
    int index = tab_bar_->addTab(tabCaption.c_str());
    tab_bar_->setTabData(index, qlonglong(w));
    id_map_[qlonglong(w)]=w;
    //connect slots and sigals for removing the spectrum from the bar, when it is closed
    connect(w,SIGNAL(destroyed(QObject*)),this,SLOT(removeWidgetFromBar(QObject*)));
    tab_bar_->setCurrentIndex(index);
  }

  void TOPPViewBase::maximizeActiveSpectrum()
  {
    if (ws_->activeWindow())
    {
      ws_->activeWindow()->showMaximized();
    }
  }

  void TOPPViewBase::focusByTab(int index)
  {
		std::map<qlonglong,SpectrumWindow*>::iterator it = id_map_.find(tab_bar_->tabData(index).toInt());
		if ( it != id_map_.end())
		{
  		it->second->setFocus();
  	}
  	else
  	{
  		cout << "focusByTab: Could not find tab with index '" << index << "'!" << endl;
  	}
  }

  void TOPPViewBase::saveImage()
  {
    //check if there is a active window
    SpectrumWindow* window = activeWindow_();
    if (window!=0)
    {
      SaveImageDialog* dialog = new SaveImageDialog(this);
      dialog->setSize(1024,768);
      if (dialog->exec())
      {
        QString format=dialog->getFormat();
        QString file_name = Q3FileDialog::getSaveFileName( window->caption().section('.',0,0),
                            format+" Images(*."+format+" *."+format.lower()+")",
                            this, "save image dialog","Select file to save" );
        if (!file_name.isEmpty())
        {
          //append missing file extension
          if (!file_name.upper().endsWith(format))
          {
            file_name.append("."+format.lower());
          }

          QImage image = window->widget()->getImage(dialog->getXSize(),dialog->getYSize());
          image.save(file_name,format,100);
        }
      }
    }
  }

  void TOPPViewBase::print()
  {
#ifndef QT_NO_PRINTER
    SpectrumWindow* window = activeWindow_();
    if (window!=0)
    {
      QPrinter* printer = new QPrinter(QPrinter::HighResolution);
      printer->setResolution(300);
      if (printer->setup(this))
      {
        QPainter p;
        if (!p.begin(printer))
          return;
        Q3PaintDeviceMetrics metrics(p.device());
        unsigned int dpix = metrics.logicalDpiX();
        unsigned int dpiy = metrics.logicalDpiY();
        QRect body(dpix,dpiy,metrics.width()-2*dpix,metrics.height()-2*dpiy);			// one inch margin
        QImage image = window->widget()->getImage(body.width(),body.height());
        p.drawImage(body,image);
        QString titel = QString("%1\n%2").arg(window->caption().section('/',-1)).arg(QDate::currentDate().toString());
        //	p.drawText(dpix,0,body.width(),dpiy, Qt::AlignCenter, titel);
        p.drawText(dpix,body.height()+dpiy, body.width(), dpiy, Qt::AlignCenter, titel);
      }
      delete(printer);
    }
#endif

  }

  void TOPPViewBase::closeFile()
  {
    //check if there is a active window
    if (ws_->activeWindow())
    {
      ws_->activeWindow()->close();
    }
  }

  void TOPPViewBase::saveLayer()
  {
    //check if there is a active window
    if (ws_->activeWindow())
    {
      const LayerData& layer = activeWindow_()->widget()->canvas()->getCurrentLayer();
      //warn if hidden layer => wrong layer selected...
    	if (!layer.visible)
    	{
    		QMessageBox::warning(this,"Warning","The current layer is not visible!");
    	}
    	//Visible area
    	const SpectrumCanvas::AreaType& area = activeWindow_()->widget()->canvas()->getVisibleArea();
    	
    	if (layer.type==LayerData::DT_PEAK)
    	{
    		//Extract selected visible data to out
    		LayerData::ExperimentType out;
    		out.ExperimentalSettings::operator=(layer.peaks);
    		LayerData::ExperimentType::ConstIterator begin;
    		LayerData::ExperimentType::ConstIterator end; 
    		if (layer.peaks.size()==1)
    		{
	    		begin = layer.peaks.begin();
	    		end = layer.peaks.end();
    		}
    		else
    		{
	    		begin = layer.peaks.RTBegin(area.min()[1]);
	    		end = layer.peaks.RTBegin(area.max()[1]);
    		}
    		out.resize(end-begin);
				
				UnsignedInt i = 0;
    		for (LayerData::ExperimentType::ConstIterator it=begin; it!=end; ++it)
    		{
  				out[i].SpectrumSettings::operator=(*it);
  				out[i].setRetentionTime(it->getRetentionTime());
  				out[i].setMSLevel(it->getMSLevel());
  				out[i].setPrecursorPeak(it->getPrecursorPeak());
  				for (LayerData::ExperimentType::SpectrumType::ConstIterator it2 = it->MZBegin(area.min()[0]); it2!= it->MZEnd(area.max()[0]); ++it2)
  				{
  					if ( it2->getIntensity() >= layer.min_int && it2->getIntensity() <= layer.max_int)
  					{
  						out[i].push_back(*it2);
  					}
  				}
  				++i;
    		}
    		//no extracted data
    		if (out.size()==0)
    		{
    		  QMessageBox::warning(this,"Warning","The displayed region of the current layer is empty!");
    		  return;
    		}
    		//one scan => DTA
    		else if (out.size()==1)
    		{
		      QString file_name = Q3FileDialog::getSaveFileName( prefs_.getValue("Preferences:DefaultPath").toString().c_str(),
					                    "DTA files (*.dta)",
					                    this, "Save spectrum dialog","Select filename for spectrum" );
					if (!file_name.isEmpty())
					{
					  DTAFile().store(file_name.ascii(),out[0]);
					}
    		}
    		//more than one scan => MzData
    		else
    		{
		      QString file_name = Q3FileDialog::getSaveFileName( prefs_.getValue("Preferences:DefaultPath").toString().c_str(),
					                    "MzData files (*.mzData)",
					                    this, "Save map dialog","Select filename for map" );
					if (!file_name.isEmpty())
					{
					  MzDataFile().store(file_name.ascii(),out);
					}
    		}
			}
			else //feature data
			{
		    enum DimensionId
		    {
	        RT = DimensionDescription < LCMS_Tag >::RT,
	        MZ = DimensionDescription < LCMS_Tag >::MZ
		    };
	    
    		//Extract selected visible data to out
    		LayerData::FeatureMapType out;
    		out.ExperimentalSettings::operator=(layer.features);
    		for (LayerData::FeatureMapType::ConstIterator it=layer.features.begin(); it!=layer.features.end(); ++it)
    		{
					if ( it->getIntensity() >= layer.min_int && 
							 it->getIntensity() <= layer.max_int &&
							 it->getPosition()[RT] >= area.min()[1] &&
							 it->getPosition()[RT] <= area.max()[1] &&
							 it->getPosition()[MZ] >= area.min()[0] &&
							 it->getPosition()[MZ] <= area.max()[0]
						 )
					{
						out.push_back(*it);
					}
  			}
    		//no extracted data
    		if (out.size()==0)
    		{
    		  QMessageBox::warning(this,"Warning","The displayed region of the current layer is empty!");
    		  return;
    		}
    		else
    		{
		      QString file_name = Q3FileDialog::getSaveFileName( prefs_.getValue("Preferences:DefaultPath").toString().c_str(),
					                    "features files (*.feat)",
					                    this, "Save feature data dialog","Select filename for feature data" );
					if (!file_name.isEmpty())
					{
					  DFeatureMapFile().store(file_name.ascii(),out);
					}
    		}
			}
    }
  }

  void TOPPViewBase::editMetadata()
  {
    //check if there is a active window
    if (ws_->activeWindow())
    {
      const LayerData& layer = activeWindow_()->widget()->canvas()->getCurrentLayer();
      //warn if hidden layer => wrong layer selected...
    	if (!layer.visible)
    	{
    		QMessageBox::warning(this,"Warning","The current layer is not visible!");
    	}
			MSMetaDataExplorer dlg(true, this);
      dlg.setCaption("Edit meta data");
			if (layer.type==LayerData::DT_PEAK) //peak data
    	{
    		dlg.add(&(const_cast<LayerData&>(layer).peaks));
    	}
    	else //feature data
    	{
    		dlg.add(&(const_cast<LayerData&>(layer).features));
    	}
      dlg.exec();
    }
  }

  void TOPPViewBase::layerPreferencesDialog()
  {
    if (ws_->activeWindow())
    {
      activeWindow_()->setActive(true);
	  	if (showPreferencesDialog())
	    {
	      savePreferences();
	    }
    }
  }

  void TOPPViewBase::layerIntensityDistribution()
  {
    //check if there is a active window
    if (ws_->activeWindow())
    {
      activeWindow_()->widget()->showIntensityDistribution();
    }  	
  }

  void TOPPViewBase::changeAxisVisibility()
  {
    //check if there is a active window
    if (ws_->activeWindow())
    {
      activeWindow_()->widget()->showLegend(!activeWindow_()->widget()->isLegendShown());
    }  	
  }

  void TOPPViewBase::closeFileByTab(int index)
  {
		std::map<qlonglong,SpectrumWindow*>::iterator it = id_map_.find(tab_bar_->tabData(index).toInt());
		if ( it != id_map_.end())
		{
  		it->second->close();
  	}
  	else
  	{
  		cout << "closeFileByTab: Could not find tab with index '" << index << "'!" << endl;
  	}
  }

  TOPPViewBase::~TOPPViewBase()
  {
    //do not add anything here. This class is a singleton
    //use closeEvent(...) to do the cleanup
  }

  void TOPPViewBase::createToolBar_()
  {
    tool_bar_ = new Q3ToolBar(this,"toolbar");

    //action modes
    action_modes_ = new Q3ActionGroup(tool_bar_);
    action_modes_->setExclusive(TRUE);
    am_zoom_ = new Q3Action( QString("Action: Zoom"), QPixmap(XPM_zoom), NULL, Qt::Key_Z, action_modes_,"AM_ZOOM",TRUE);
    am_zoom_->addTo(tool_bar_);
    am_translate_ = new Q3Action( QString("Action: Translate"), QPixmap(XPM_translate), NULL, Qt::Key_T, action_modes_,"AM_TRANSLATE",TRUE);
    am_translate_->addTo(tool_bar_);
    am_select_ = new Q3Action( QString("Action: Select"), QPixmap(XPM_select), NULL, Qt::Key_S, action_modes_,"AM_SELECT",TRUE);
    am_select_->addTo(tool_bar_);
    am_measure_ = new Q3Action( QString("Action: Measure"), QPixmap(XPM_measure), NULL, Qt::Key_M, action_modes_,"AM_MEASURE",TRUE);
    am_measure_->addTo(tool_bar_);
    connect(action_modes_,SIGNAL(selected(Q3Action*)),this,SLOT(setActionMode(Q3Action*)));

    tool_bar_->addSeparator();

    //intensity modes
    intensity_modes_ = new Q3ActionGroup(tool_bar_);
    intensity_modes_->setExclusive(TRUE);
    im_none_ = new Q3Action( QString("Intensity: Normal"), QPixmap(XPM_lin), NULL, Qt::Key_N, intensity_modes_,"IM_NONE",TRUE);
    im_none_->addTo(tool_bar_);
    im_log_ = new Q3Action( QString("Intensity: Logarithmic"), QPixmap(XPM_log), NULL, Qt::Key_L, intensity_modes_,"IM_LOG",TRUE);
    im_log_->addTo(tool_bar_);
    im_percentage_ = new Q3Action( QString("Intensity: Percentage"), QPixmap(XPM_percentage), NULL, Qt::Key_P, intensity_modes_,"IM_PERCENTAGE",TRUE);
    im_percentage_->addTo(tool_bar_);
    im_snap_ = new Q3Action( QString("Intensity: Snap to maximum displayed intensity"), QPixmap(XPM_snap), NULL, Qt::Key_A, intensity_modes_,"IM_SNAP",TRUE);
    im_snap_->addTo(tool_bar_);
    connect(intensity_modes_,SIGNAL(selected(Q3Action*)),this,SLOT(setIntensityMode(Q3Action*)));

    tool_bar_->addSeparator();

    //common buttons
    reset_zoom_button_ = new QToolButton(QIcon(QPixmap(XPM_reset_zoom)),"Reset Zoom (Backspace)", "Reset Zoom", NULL, NULL , tool_bar_, "resetZoomButton");
    reset_zoom_button_->setAccel(Qt::Key_Backspace);
    connect(reset_zoom_button_,SIGNAL(clicked()),this,SLOT(resetZoom()));

    tool_bar_->addSeparator();

    grid_button_ = new QToolButton(QIcon(QPixmap(XPM_grid)),"Show grid (G)","Show grid",NULL, NULL ,tool_bar_,"gridButton");
    grid_button_->setAccel(Qt::Key_G);
    grid_button_->setToggleButton(true);
    connect(grid_button_,SIGNAL(toggled(bool)),this,SLOT(showGridLines(bool)));

    tool_bar_->addSeparator();

    print_button_ = new QToolButton(QIcon(QPixmap(XPM_print)),"Print (Ctrl + P)","print",NULL, NULL,tool_bar_,"printButton");
    print_button_->setAccel(Qt::CTRL + Qt::Key_P);
    connect(print_button_,SIGNAL(clicked()),this,SLOT(print()));

    tool_bar_->resize(tool_bar_->sizeHint());
    tool_bar_->show();

    // 1d toolbar
    tool_bar_1d_ = new Q3ToolBar(this,"toolbar");

    draw_modes_ = new Q3ActionGroup(tool_bar_1d_);
    draw_modes_->setExclusive(TRUE);
    dm_peaks_1d_ = new Q3Action( QString("Stick mode"), QPixmap(XPM_peaks), NULL, Qt::Key_I, draw_modes_,"DM_PEAKS",TRUE);
    dm_peaks_1d_->addTo(tool_bar_1d_);
    dm_rawdata_1d_ = new Q3Action( QString("Raw data mode"), QPixmap(XPM_lines), NULL, Qt::Key_R, draw_modes_,"DM_CONNECTEDLINES",TRUE);
    dm_rawdata_1d_->addTo(tool_bar_1d_);
    connect(draw_modes_,SIGNAL(selected(Q3Action*)),this,SLOT(setDrawMode1D(Q3Action*)));

    tool_bar_1d_->addSeparator();

    link_box_ = new QComboBox(tool_bar_1d_);
    QToolTip::add
      (link_box_,"Use this combobox to link two spectra.\nLinked spectra zoom in/out together");
    connect(link_box_,SIGNAL(activated(const QString&)),this,SLOT(linkActiveTo(const QString&)));

    // 2d toolbar
    tool_bar_2d_ = new Q3ToolBar(this,"toolbar");

    dm_points_2d_ = new QToolButton(QIcon(QPixmap(XPM_points)), "Show dots (D)", "Show dots", 0, 0, tool_bar_2d_, "showPoints");
    dm_points_2d_->setAccel(Qt::Key_D);
    dm_points_2d_->setToggleButton(true);
    connect(dm_points_2d_, SIGNAL(toggled(bool)), this, SLOT(showPoints(bool)));

    dm_surface_2d_ = new QToolButton(QIcon(QPixmap(XPM_colors)), "Show colored surface (U)", "Show colored surface", 0, 0, tool_bar_2d_, "showSurface");
    dm_surface_2d_->setAccel(Qt::Key_U);
    dm_surface_2d_->setToggleButton(true);
    connect(dm_surface_2d_, SIGNAL(toggled(bool)), this, SLOT(showSurface(bool)));

    dm_contours_2d_ = new QToolButton(QIcon(QPixmap(XPM_contours)), "Show contour lines (C)", "Show contour lines", 0, 0, tool_bar_2d_, "showContours");
    dm_contours_2d_->setAccel(Qt::Key_C);
    dm_contours_2d_->setToggleButton(true);
    connect(dm_contours_2d_, SIGNAL(toggled(bool)), this, SLOT(showContours(bool)));
  }

  void TOPPViewBase::linkActiveTo(const QString& path)
  {
    unlinkActive_();
    if (path!="<unlinked>")
    {
      //link spectras
      QWidgetList windows = ws_->windowList();
      for ( int i = 0; i < int(windows.count()); ++i )
      {
        QWidget *window = windows.at(i);
        if (File::basename(window->caption().toAscii().data())+"  ("+window->caption().ascii()+")"==path.toAscii().data())
        {
          //connect the slots
          connect(activeWindow_()->widget()->canvas(),SIGNAL(visibleAreaChanged(DRange<2>)),dynamic_cast<SpectrumWindow*>(window)->widget()->canvas(),SLOT(setVisibleArea(DRange<2>)));
          connect(dynamic_cast<SpectrumWindow*>(window)->widget()->canvas(),SIGNAL(visibleAreaChanged(DRange<2>)),activeWindow_()->widget()->canvas(),SLOT(setVisibleArea(DRange<2>)));
          //add links to the map
          link_map_[qlonglong(ws_->activeWindow())]=qlonglong(window);
          link_map_[qlonglong(window)]=qlonglong(ws_->activeWindow());
        }
      }
    }

  }

  void TOPPViewBase::unlinkActive_()
  {
    qlonglong active_address = qlonglong(ws_->activeWindow());
    qlonglong active_linked_to_address = link_map_[active_address];
    if (active_linked_to_address != 0)
    {
      //remove signals
      disconnect(id_map_[active_linked_to_address]->widget()->canvas(),SIGNAL(visibleAreaChanged(DRange<2>)), activeWindow_()->widget()->canvas(),SLOT(setVisibleArea(DRange<2>)));
      disconnect(activeWindow_()->widget()->canvas(),SIGNAL(visibleAreaChanged(DRange<2>)), id_map_[active_linked_to_address]->widget()->canvas(),SLOT(setVisibleArea(DRange<2>)));
      //remove from the map
      link_map_.erase(active_address);
      link_map_.erase(active_linked_to_address);
    }
  }

  void TOPPViewBase::showStatusMessage(string msg, OpenMS::UnsignedInt time)
  {
    if (time==0)
    {
      message_label_->setText(msg.c_str());
      statusBar()->repaint();
    }
    else
    {
      statusBar()->message(msg.c_str(), time);
    }
  }

  void TOPPViewBase::showCursorStatus(double mz, double intensity, double rt)
  {
    message_label_->setText("");
    if (mz==-1)
    {
      mz_label_->setText("m/z: ");
    }
    else
    {
      mz_label_->setText(("m/z: "+String(mz,8).fillLeft(' ',8)).c_str());
    }
    if (rt==-1)
    {
      rt_label_->setText("RT: ");
    }
    else
    {
      rt_label_->setText(("RT: "+String(rt,8).fillLeft(' ',8)).c_str());
    }
    if (intensity==-1)
    {
      int_label_->setText("Int: ");
    }
    else
    {
      int_label_->setText(("Int: "+String(intensity,12).fillLeft(' ',12)).c_str());
    }
    statusBar()->repaint();
  }

  void TOPPViewBase::showGridLines(bool b)
  {
    SpectrumWindow* window = activeWindow_();
    if (window!=0)
    {
      window->widget()->canvas()->showGridLines(b);
    }
  }

  void TOPPViewBase::resetZoom()
  {
    SpectrumWindow* window = activeWindow_();
    if (window!=0)
    {
      window->widget()->canvas()->resetZoom();
    }
  }

  void TOPPViewBase::setActionMode(Q3Action* a)
  {
    SpectrumWindow* w = activeWindow_();
    if (w)
    {
      string name = a->name();
      if(name=="AM_SELECT")
        w->widget()->setActionMode(SpectrumCanvas::SpectrumCanvas::AM_SELECT);
      else if (name=="AM_ZOOM")
        w->widget()->setActionMode(SpectrumCanvas::SpectrumCanvas::AM_ZOOM);
      else if(name=="AM_TRANSLATE")
        w->widget()->setActionMode(SpectrumCanvas::SpectrumCanvas::AM_TRANSLATE);
      else if(name=="AM_MEASURE")
        w->widget()->setActionMode(SpectrumCanvas::SpectrumCanvas::AM_MEASURE);
      else
        throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    };
  }

  void TOPPViewBase::setIntensityMode(Q3Action* a)
  {
    SpectrumWindow* w = activeWindow_();
    if (w)
    {
      string name = a->name();
      if(name=="IM_NONE")
        w->widget()->setIntensityMode(SpectrumCanvas::SpectrumCanvas::IM_NONE);
      else if (name=="IM_LOG")
        w->widget()->setIntensityMode(SpectrumCanvas::SpectrumCanvas::IM_LOG);
      else if(name=="IM_PERCENTAGE")
        w->widget()->setIntensityMode(SpectrumCanvas::SpectrumCanvas::IM_PERCENTAGE);
      else if(name=="IM_SNAP")
        w->widget()->setIntensityMode(SpectrumCanvas::SpectrumCanvas::IM_SNAP);
      else
        throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    };
  }

  void TOPPViewBase::setDrawMode1D(Q3Action* a)
  {
    Spectrum1DWindow* w = active1DWindow_();
    if (w)
    {
      string name = a->name();
      if (name == "DM_PEAKS")
        w->widget()->canvas()->setDrawMode(Spectrum1DCanvas::DM_PEAKS);
      else if (name == "DM_CONNECTEDLINES")
        w->widget()->canvas()->setDrawMode(Spectrum1DCanvas::DM_CONNECTEDLINES);
      else
        throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
    }
  }

  void TOPPViewBase::showPoints(bool on)
  {
    if (Spectrum2DWindow* win = active2DWindow_())
    {
      win->widget()->canvas()->showPoints(on);
    }
  }

  void TOPPViewBase::showSurface(bool on)
  {
    if (Spectrum2DWindow* win = active2DWindow_())
    {
      win->widget()->canvas()->showSurface(on);
    }
  }

  void TOPPViewBase::showContours(bool on)
  {
    if (Spectrum2DWindow* win = active2DWindow_())
    {
      win->widget()->canvas()->showContours(on);
    }
  }

  void TOPPViewBase::updateToolbar(QWidget* /*widget*/)
  {
    SpectrumWindow* w = activeWindow_();

    if (w)
    {
      //set action mode
      switch (w->widget()->getActionMode())
      {
          case SpectrumCanvas::AM_SELECT:
          am_select_->setOn(true);
          break;
          case SpectrumCanvas::AM_ZOOM:
          am_zoom_->setOn(true);
          break;
          case SpectrumCanvas::AM_TRANSLATE:
          am_translate_->setOn(true);
          break;
          case SpectrumCanvas::AM_MEASURE:
          am_measure_->setOn(true);
          break;
          default:
          throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
      }

      //set intensity mode
      switch (w->widget()->canvas()->getIntensityMode())
      {
          case SpectrumCanvas::IM_NONE:
          im_none_->setOn(true);
          break;
          case SpectrumCanvas::IM_LOG:
          im_log_->setOn(true);
          break;
          case SpectrumCanvas::IM_PERCENTAGE:
          im_percentage_->setOn(true);
          break;
          case SpectrumCanvas::IM_SNAP:
          im_snap_->setOn(true);
          break;
          default:
          throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
      }

      //grid lines
      grid_button_->setOn(w->widget()->canvas()->gridLinesShown());
    }

    //1D
    Spectrum1DWindow* w1 = active1DWindow_();
    if (w1)
    {
      //draw mode
      switch (w1->widget()->canvas()->getDrawMode())
      {
          case Spectrum1DCanvas::DM_PEAKS:
          dm_peaks_1d_->setOn(true);
          break;
          case Spectrum1DCanvas::DM_CONNECTEDLINES:
          dm_rawdata_1d_->setOn(true);
          break;
          default:
          throw Exception::NotImplemented(__FILE__, __LINE__, __PRETTY_FUNCTION__);
      };

      //update link selector
      int current_index=0;
      int active_linked_to_address = link_map_[qlonglong(ws_->activeWindow())];
      link_box_->clear();
      link_box_->insertItem("<unlinked>");
      QWidgetList windows = ws_->windowList();
      for ( int i = 0; i < int(windows.count()); ++i )
      {
        QWidget *window = windows.at(i);
        if (window!=w)
        {
          current_index++;
          link_box_->insertItem((File::basename(window->caption().toAscii().data())+"  ("+window->caption().ascii()+")").c_str());
          if (active_linked_to_address==qlonglong(window))
          {
            link_box_->setCurrentItem(current_index);
          }
        }
      }

      //show/hide toolbars and buttons
      tool_bar_1d_->show();
      tool_bar_2d_->hide();
      am_measure_->setEnabled(false);
      am_select_->setEnabled(true);
    }

    //2d
    Spectrum2DWindow* w2 = active2DWindow_();
    if (w2)
    {
      //draw modes
      dm_points_2d_->setOn(w2->widget()->canvas()->dotsAreShown());
      dm_surface_2d_->setOn(w2->widget()->canvas()->surfaceIsShown());
      dm_contours_2d_->setOn(w2->widget()->canvas()->contoursAreShown());

      //show/hide toolbars and buttons
      tool_bar_1d_->hide();
      tool_bar_2d_->show();
      am_measure_->setEnabled(true);
      am_select_->setEnabled(true);
    }

    //1D
    Spectrum3DWindow* w3 = active3DWindow_();
    if (w3)
    {
      //show/hide toolbars and buttons
      tool_bar_1d_->hide();
      tool_bar_2d_->hide();
      am_measure_->setEnabled(false);
      am_select_->setEnabled(false);
    }
  }

  void TOPPViewBase::updateLayerbar()
  {
  	//cout << "updateLayerbar()" << endl;
    layer_bar_->hide();
		layer_manager_->clear();

    SpectrumCanvas* cc = activeCanvas_();
    if (cc == 0)
    {
      return;
    }
		Q3CheckListItem* item = 0;
    for (UnsignedInt i = 0; i<cc->getLayerCount(); ++i)
    {
    	//add item
    	item = new Q3CheckListItem( layer_manager_, item, cc->getLayer(i).name.c_str(), Q3CheckListItem::CheckBox );
    	//set visibility
    	if (cc->getLayer(i).visible)
    	{
    		item->setState(Q3CheckListItem::On);
    	}
    	//highlight active item
    	if (i == cc->activeLayerIndex())
    	{
		    layer_manager_->blockSignals(true);
				layer_manager_->setSelected(item,true);
				layer_manager_->blockSignals(false);
    	}
    }
    layer_bar_->show();
  }

	void TOPPViewBase::layerSelectionChange()
	{
		//cout << "layerSelectionChange()" << endl;
		//get current canvas
		SpectrumCanvas* cc = activeCanvas_();
		//nothing selcted -> find last active item and select it
		if (layer_manager_->selectedItem() == 0)
		{
			Q3ListViewItemIterator it( layer_manager_ );
	    for (unsigned int i = 0; i < cc->activeLayerIndex(); ++i) 
	    {
				++it;
	    }
	    //cout << "  RESELECTING: " << cc->activeLayerIndex() << endl;
	    layer_manager_->blockSignals(true);
			layer_manager_->setSelected(*it,true);
			layer_manager_->blockSignals(false);
		}
		// new layer selected -> highlight it
		else
		{
	    int i = 0;
	    Q3ListViewItemIterator it( layer_manager_ );
	    while (it.current()) 
	    {
	      if (it.current()->isSelected())
	      {
	      	//cout << "  SELECTING: " << i << endl;
	      	layer_manager_->blockSignals(true);
	      	layer_manager_->setSelected(*it,true);
	      	layer_manager_->blockSignals(false);
	      	cc->activateLayer(i);
	      	//cout << "  SELECTED: " << i << endl;
	      	break;
	      }
				++it;
				++i;
	    }
		}
	}

	void TOPPViewBase::layerContextMenu(Q3ListViewItem* item, const QPoint & pos, int /*col*/)
	{
		if (item && item!=layer_manager_->firstChild())
		{
			Q3PopupMenu* context_menu = new Q3PopupMenu(layer_manager_);
			context_menu->insertItem("Delete",0,0);
			int result = context_menu->exec(pos);
			//delete
			if (result == 0)
			{
		 		int i = 0;
		    Q3ListViewItemIterator it( layer_manager_ );
		    while (it.current()) 
		    {
		      if (it.current()==item)
		      {
		  			activeCanvas_()->removeLayer(i);
						updateLayerbar();
						break;
		      }
					++it;
					++i;
		    }
			}
			delete (context_menu);
		}
	}

	void TOPPViewBase::layerVisibilityChange(Q3ListViewItem* item, const QPoint& /*pnt*/, int /*col*/)
	{
		//cout << "layerVisibilityChange() " << endl;
		if (item)
		{
			SpectrumCanvas* cc = activeCanvas_();
			int i = 0;
	    Q3ListViewItemIterator it( layer_manager_ );
	    while (it.current()) 
	    {
	    	if (((Q3CheckListItem*)(it.current()))->isOn() != cc->getLayer(i).visible)
	    	{
	    		//cout << "  SHOWING/HIDING: " << i << endl;
	    		cc->changeVisibility(i,!cc->getLayer(i).visible);
	    		break;
	    	}
				++it;
				++i;
	    }
		}
	}

  void TOPPViewBase::updateTabBar(QWidget* w)
  {
    if (w)
    {
      for (int i=0; i<tab_bar_->count(); ++i)
      {
      	if (tab_bar_->tabData(i).toLongLong() == qlonglong(w))
      	{
      		tab_bar_->setCurrentIndex(i);
      		break;
      	}
      }
    }
  }

  void TOPPViewBase::tileVertical()
  {
    // primitive horizontal tiling
    QWidgetList windows = ws_->windowList();
    if ( !windows.count() )
      return;

    if (active1DWindow_())
      active1DWindow_()->showNormal();
    if (active2DWindow_())
      active2DWindow_()->showNormal();

    int heightForEach = ws_->height() / windows.count();
    int y = 0;
    for ( int i = 0; i < int(windows.count()); ++i )
    {
      QWidget *window = windows.at(i);
      if ( window->isMaximized() || window->isFullScreen() )
      {

        // prevent flicker
        window->hide();
        window->setWindowState(Qt::WindowNoState);
        window->show();
      }
      int preferredHeight = window->minimumHeight()+window->parentWidget()->baseSize().height();
      int actHeight = QMAX(heightForEach, preferredHeight);

      window->parentWidget()->setGeometry( 0, y, ws_->width(), actHeight );
      y += actHeight;
    }
  }

  void TOPPViewBase::tileHorizontal()
  {
    // primitive horizontal tiling
    QWidgetList windows = ws_->windowList();
    if ( !windows.count() )
      return;

    if (active1DWindow_())
      active1DWindow_()->showNormal();
    if (active2DWindow_())
      active2DWindow_()->showNormal();

    int widthForEach = ws_->width() / windows.count();
    int y = 0;
    for ( int i = 0; i < int(windows.count()); ++i )
    {
      QWidget *window = windows.at(i);
      if ( window->windowState() & Qt::WindowMaximized )
      {
        // prevent flicker
        window->hide();
        window->showNormal();
      }
      int preferredWidth = window->minimumWidth()+window->parentWidget()->baseSize().width();

      int actWidth = QMAX(widthForEach, preferredWidth);

      window->parentWidget()->setGeometry( y, 0, actWidth , ws_->height() );
      y += actWidth;
    }
  }

  void TOPPViewBase::removeWidgetFromBar(QObject* o)
  {
    for (int i=0; i<tab_bar_->count(); ++i)
    {
    	if (tab_bar_->tabData(i).toLongLong() == qlonglong(o))
    	{
		    tab_bar_->removeTab(i);
		    id_map_.erase(qlonglong(o));
    		break;
    	}
    }
  }

  void TOPPViewBase::connectWindowSignals_(SpectrumWindow* sw)
  {
    connect(sw->widget()->canvas(),SIGNAL(layerActivated(QWidget*)),this,SLOT(updateToolbar(QWidget*)));
    connect(sw,SIGNAL(sendStatusMessage(std::string,OpenMS::UnsignedInt)),this,SLOT(showStatusMessage(std::string,OpenMS::UnsignedInt)));
    connect(sw,SIGNAL(sendCursorStatus(double,double,double)),this,SLOT(showCursorStatus(double,double,double)));
    connect(sw,SIGNAL(modesChanged(QWidget*)),this,SLOT(updateToolbar(QWidget*)));
    connect(sw,SIGNAL(destroyed()),this,SLOT(windowClosed()));
  
  	Spectrum2DWindow* sw2 = dynamic_cast<Spectrum2DWindow*>(sw);
  	if (sw2 != 0)
  	{
  		connect(sw2->getHorizontalProjection(),SIGNAL(sendCursorStatus(double,double,double)),this,SLOT(showCursorStatus(double,double,double)));
  		connect(sw2->getVerticalProjection(),SIGNAL(sendCursorStatus(double,double,double)),this,SLOT(showCursorStatus(double,double,double)));
  	}
  }

  //! returns selected peaks of active spectrum framed by \c layer_index_.begin() and the last peak BEFORE \c layer_index_.end();
  vector<MSExperiment<>::SpectrumType::Iterator> TOPPViewBase::getActiveSpectrumSelectedPeaks()
  {
    Spectrum1DWindow* w1 = active1DWindow_();
    if (w1)
    {
      return (w1->widget()->canvas()->getSelectedPeaks());
    }
    return vector<MSExperiment<>::SpectrumType::Iterator>();
  }

  void TOPPViewBase::gotoDialog()
  {
    SpectrumWindow* w = activeWindow_();
    if (w)
    {
      w->showGoToDialog();
    }
  }


  void TOPPViewBase::showPeaklistActiveSpectrum()
  {
    std::vector<MSExperiment<>::SpectrumType::Iterator> peaks = getActiveSpectrumSelectedPeaks();

    //only if peaks selected:
    if (peaks.size() >= 3)
    {
      std::ostringstream peaklist;

      for (std::vector<MSExperiment<>::SpectrumType::Iterator>::iterator it = peaks.begin(); it != peaks.end(); it++)
      {
        if (it == peaks.begin())
        {
          peaklist << "First Peak in Spectrum: Position " << (**it).getPosition()[0] << ", Intensity " << (**it).getIntensity() << endl;
        }
        else if (*it == *(peaks.rbegin()))
        {
          peaklist << "Last Peak in Spectrum: Position " << (**it).getPosition()[0] << ", Intensity " << (**it).getIntensity();
        }
        else
        {
          peaklist << "Selected Peak: Position " << (**it).getPosition()[0] << ", Intensity " << (**it).getIntensity() << endl;
        }
      }
      QMessageBox::information(this, QString("Peaklist"), QString(peaklist.str().c_str()));
    }
    else
    {
      QMessageBox::information(this, QString("Peaklist"), QString("No Peaks selected!"));
    }

  }

  void TOPPViewBase::smoothActiveSpectrum()
  {
    SmoothingDialog dialog(this,"Open Smoothing Dialog");
    if (dialog.exec())
    {
      float kernel_width = dialog.getKernelWidth();
			float spacing = dialog.getSpacing();
			bool resampling_flag = dialog.getResampling();
      bool sgolay_flag = dialog.getSGolay();
      
      // 1D smoothing
      Spectrum1DWindow* w = active1DWindow_();
      if (w!=0)
      {
      	// raw data spectrum
        const Spectrum1DCanvas::ExperimentType& exp_raw = w->widget()->canvas()->getCurrentPeakData();
				
				//add new layer
        String new_name = w->widget()->canvas()->getCurrentLayer().name+" (smoothed)";
        Spectrum1DCanvas::ExperimentType& exp_smoothed = w->widget()->canvas()->addEmptyPeakLayer();

        // add one spectrum
        exp_smoothed.resize(1);
      	if (sgolay_flag)
        {
        	SavitzkyGolaySVDFilter sgolay;
        	try
	        {
	          sgolay.setOrder(dialog.getSGolayOrder());
	
	          // if resampling take the resampling spacing
	          if (resampling_flag)
	          { 
		          // and determine the number of kernel coefficients
		          int frame_size = (int) ceil(kernel_width / spacing + 1);
		
		          // the number has to be odd
		          if (!isOdd(frame_size))
		          {
		            frame_size += 1;
		          }
		          sgolay.setWindowSize(frame_size);
		          
		          Spectrum1DCanvas::ExperimentType::SpectrumType resampled_spectrum;
		          LinearResampler resampler;
		          resampler.setSpacing(spacing);
		          resampler.raster(exp_raw[0],resampled_spectrum);
		    
		          sgolay.filter(resampled_spectrum,exp_smoothed[0]);
		        }
		        // savitzky golay without resampling
		        else
		        {
		        	// else compute the spacing of data
			        float s =  ((exp_raw[0].end()-1)->getPos() - exp_raw[0].begin()->getPos()) / (exp_raw[0].size() + 1);
			        
			        // and determine the number of kernel coefficients
			        int frame_size = (int) ceil(kernel_width / s + 1);
			
			        // the number has to be odd
			        if (!isOdd(frame_size))
			        {
			         frame_size += 1;
			        }
			        sgolay.setWindowSize(frame_size);      
		          sgolay.filter(exp_raw[0],exp_smoothed[0]);
	          }
	        }
	        catch (Exception::InvalidValue)
	        {
	        	QMessageBox::warning(this,"Order of the smoothing polynomial too large!","Choose a smaller order or enlarge the width of the smoothing kernel.");
	        	w->widget()->canvas()->finishAdding();
	        	w->widget()->canvas()->setCurrentLayerName(new_name);
						return;
	        }
        }
        // gaussian smoothing
        else
        {
        	GaussFilter gauss;
        	
          gauss.setKernelWidth(kernel_width);
          gauss.filter(exp_raw[0],exp_smoothed[0]);
        }

        //color smoothed data
        for (Spectrum1DCanvas::ExperimentType::SpectrumType::Iterator it = exp_smoothed[0].begin(); it!= exp_smoothed[0].end(); ++it)
        {
          it->setMetaValue(UnsignedInt(5),string("#FF00FF"));
        }

        w->widget()->canvas()->finishAdding();
        w->widget()->canvas()->setCurrentLayerName(new_name);
      }
      // 2D window
      else
      {
        Spectrum2DWindow* w2 = active2DWindow_();
        if (w2!=0)
        {
          const Spectrum2DCanvas::ExperimentType& exp_raw = w2->widget()->canvas()->getCurrentPeakData();
          	
         	//add new window for picked peaks
          Spectrum2DWindow* w_smoothed = new Spectrum2DWindow(ws_,Qt::WDestructiveClose);
          //set main preferences
          w_smoothed->setMainPreferences(prefs_);
          String new_name = w2->widget()->canvas()->getCurrentLayer().name+" (smoothed)";

          Spectrum2DCanvas::ExperimentType& exp2 = w_smoothed->widget()->canvas()->addEmptyPeakLayer();

          String filename = w2->widget()->canvas()->getCurrentLayer().name+"_smoothed";

					// savitzky golay filtering

					if (sgolay_flag)
        	{
	        	SavitzkyGolaySVDFilter sgolay;
	        	try
	        	{
		          sgolay.setOrder(dialog.getSGolayOrder());
	
		          // if resampling take the resampling spacing
		          if (resampling_flag)
		          { 
			          // and determine the number of kernel coefficients
			          int frame_size = (int) ceil(kernel_width / spacing + 1);
			
			          // the number has to be odd
			          if (!isOdd(frame_size))
			          {
			            frame_size += 1;
			          }
			          sgolay.setWindowSize(frame_size);
		          
			          Spectrum2DCanvas::ExperimentType resampled_experiment;
	            	LinearResampler lin_resampler;
	            	lin_resampler.setSpacing(spacing);
	
	            	unsigned int n = exp_raw.size();
	            	// resample and filter every scan
	            	for (unsigned int i = 0; i < n; ++i)
	            	{
		              // temporary container for the resampled data
		              Spectrum2DCanvas::ExperimentType::SpectrumType resampled_data;
		              lin_resampler.raster(exp_raw[i],resampled_data);
		
		              Spectrum2DCanvas::ExperimentType::SpectrumType spectrum;
		              sgolay.filter(resampled_data, spectrum);
	
		              // if any peaks are found copy the spectrum settings
		              if (spectrum.size() > 0)
		              {
	                	exp2.push_back(spectrum);
	              	}
	            	}
	          	}
	          	// savitzky golay filtering without resampling
	          	else
	          	{
	          		// else compute the spacing of data
				        float s =  ((exp_raw[0].end()-1)->getPos() - exp_raw[0].begin()->getPos()) / (exp_raw[0].size() + 1);
				        
				        // and determine the number of kernel coefficients
				        int frame_size = (int) ceil(kernel_width / s + 1);
				
				        // the number has to be odd
				        if (!isOdd(frame_size))
				        {
			         		frame_size += 1;
			        	}
				        sgolay.setWindowSize(frame_size);      
	          		sgolay.filterExperiment(exp_raw,exp2);
	            }
          	}
            catch (Exception::InvalidValue)
	        	{
	        		QMessageBox::warning(this,"Order of the smoothing polynomial too large!","Choose a smaller order or enlarge the width of the smoothing kernel.");
	        	
	        		delete w_smoothed;
							return;
	        	}
          }

          // gaussian filtering
          else
          {
           	GaussFilter gauss;
           	
           	gauss.setKernelWidth(kernel_width);
            gauss.filterExperiment(exp_raw,exp2);
          }
           
	      	w_smoothed->widget()->canvas()->finishAdding();
					w_smoothed->widget()->canvas()->setCurrentLayerName(new_name);
					
	        connectWindowSignals_(w_smoothed);
	        w_smoothed->setCaption(new_name.c_str());
	        addClient(w_smoothed,filename);
	        addTab_(w_smoothed,new_name);
	
	        w_smoothed->showMaximized();
	        //           String gradient_peaks("Linear|0,#dbffcf;100,#00ff00");
	        //           w_smoothed->widget()->canvas()->setDotGradient(gradient_peaks);
	      }
	    }
      updateLayerbar();
    }
  }



  void TOPPViewBase::baselineFilteringActiveSpectrum()
  {
    BaselineFilteringDialog dialog(this,"Open Smoothing Dialog");
    if (dialog.exec())
    {
      // 1D baseline filtering
      Spectrum1DWindow* w = active1DWindow_();
      if (w!=0)
      {
        const Spectrum1DCanvas::ExperimentType& exp_raw = w->widget()->canvas()->getCurrentPeakData();
        TopHatFilter tophat;
        tophat.setStrucElemSize(dialog.getStrucElemWidth());

        bool resampling_flag = dialog.getResampling();

        //add new layer
        String new_name = w->widget()->canvas()->getCurrentLayer().name+" (basline)";
        Spectrum1DCanvas::ExperimentType& exp_filtered = w->widget()->canvas()->addEmptyPeakLayer();

        // add one spectrum
        exp_filtered.resize(1);

        // Resampling before baseline filtering?
        if (resampling_flag)
        {
          Spectrum1DCanvas::ExperimentType::SpectrumType resampled_spectrum;
          LinearResampler resampler;
          resampler.setSpacing(dialog.getSpacing());
          resampler.raster(exp_raw[0],resampled_spectrum);
          tophat.filter(resampled_spectrum,exp_filtered[0]);
        }
        else
        {
          tophat.filter(exp_raw[0],exp_filtered[0]);
        }
        //color smoothed data
        for (Spectrum1DCanvas::ExperimentType::SpectrumType::Iterator it = exp_filtered[0].begin(); it!= exp_filtered[0].end(); ++it)
        {
          it->setMetaValue(UnsignedInt(5),string("#FF00FF"));
        }

        w->widget()->canvas()->finishAdding();
        w->widget()->canvas()->setCurrentLayerName(new_name);
      }
      else
      {
        Spectrum2DWindow* w2 = active2DWindow_();
        if (w2!=0)
        {
          const Spectrum2DCanvas::ExperimentType& exp_raw = w2->widget()->canvas()->getCurrentPeakData();
          TopHatFilter tophat;
          tophat.setStrucElemSize(dialog.getStrucElemWidth());

          bool resampling_flag = dialog.getResampling();

          //add new window for baseline filtered data
          Spectrum2DWindow* w_tophat = new Spectrum2DWindow(ws_,Qt::WDestructiveClose);
          //set main preferences
          w_tophat->setMainPreferences(prefs_);
          String new_name = w2->widget()->canvas()->getCurrentLayer().name+" (basline)";

          Spectrum2DCanvas::ExperimentType& exp_filtered = w_tophat->widget()->canvas()->addEmptyPeakLayer();

          String filename = w2->widget()->canvas()->getCurrentLayer().name+"_filtered";

          // Resampling before baseline filtering?
          if (resampling_flag)
          {
            Spectrum2DCanvas::ExperimentType resampled_experiment;
            LinearResampler lin_resampler;
            lin_resampler.setSpacing(dialog.getSpacing());

            unsigned int n = exp_raw.size();
            // resample and filter every scan
            for (unsigned int i = 0; i < n; ++i)
            {
              // temporary container for the resampled data
              Spectrum2DCanvas::ExperimentType::SpectrumType resampled_data;
              lin_resampler.raster(exp_raw[i],resampled_data);

              Spectrum2DCanvas::ExperimentType::SpectrumType spectrum;
              tophat.filter(resampled_data, spectrum);

              // if any peaks are found copy the spectrum settings
              if (spectrum.size() > 0)
              {
                // copy the spectrum settings
                //  static_cast<SpectrumSettings&>(spectrum) = ms_exp_raw[i];
                // spectrum.setType(SpectrumSettings::RAWDATA);

                // copy the spectrum information
                //                 spectrum.getPrecursorPeak() = ms_exp_raw[i].getPrecursorPeak();
                //                 spectrum.setRetentionTime(ms_exp_raw[i].getRetentionTime());
                //                 spectrum.setMSLevel(ms_exp_raw[i].getMSLevel());
                //                 spectrum.getName() = ms_exp_raw[i].getName();

                exp_filtered.push_back(spectrum);
              }
            }
          }
          else
          {
              tophat.filterExperiment(exp_raw,exp_filtered);
          }

          w_tophat->widget()->canvas()->finishAdding();
          w_tophat->widget()->canvas()->setCurrentLayerName(new_name);
          connectWindowSignals_(w_tophat);
          w_tophat->setCaption(new_name.c_str());
          addClient(w_tophat,filename);
          addTab_(w_tophat,new_name);

          w_tophat->showMaximized();

          //           String gradient_peaks("Linear|0,#dbffcf;100,#00ff00");
          //           w_smoothed->widget()->canvas()->setDotGradient(gradient_peaks);
        }
      }
      updateLayerbar();
    }
  }




  void TOPPViewBase::pickActiveSpectrum()
  {
    PeakPickingDialog dialog(this,"Open Peak Picking Dialog");
    if (dialog.exec())
    {
      //pick data
      PeakPickerCWT peak_picker;
      //estimate the scale a given the fwhm f
      //the fwhm of a marr wavelet is f ~ 1.252*a
      peak_picker.setWaveletScale(dialog.getFwhm() / 1.252);
      peak_picker.setFwhmBound(dialog.getFwhm());
      peak_picker.setPeakBound(dialog.getPeakHeight());
      peak_picker.setPeakBoundMs2Level(dialog.getPeakHeightMs2());
      peak_picker.setOptimizationFlag(dialog.getOptimization());
      peak_picker.setSignalToNoiseLevel(dialog.getSignalToNoise());

      Spectrum1DWindow* w = active1DWindow_();
      if (w!=0)
      {
        //add new layer
        String new_name = w->widget()->canvas()->getCurrentLayer().name+" (picked)";
        Spectrum1DCanvas::ExperimentType& exp = w->widget()->canvas()->addEmptyPeakLayer();

        // add one spectrum
        exp.resize(1);
        // pick peaks
        peak_picker.pick(w->widget()->canvas()->getCurrentPeakData()[0].begin(),w->widget()->canvas()->getCurrentPeakData()[0].end(),exp[0]);

        //color picked peaks
        for (Spectrum1DCanvas::ExperimentType::SpectrumType::Iterator it = exp[0].begin(); it!= exp[0].end(); ++it)
        {
          it->setMetaValue(UnsignedInt(5),string("#FF00FF"));
        }

        w->widget()->canvas()->finishAdding();
        w->widget()->canvas()->setCurrentLayerName(new_name);
      }
      else
      {

        Spectrum2DWindow* w2 = active2DWindow_();
        if (w2!=0)
        {
          //add new window for picked peaks
          Spectrum2DWindow* w_picked = new Spectrum2DWindow(ws_,Qt::WDestructiveClose);
          //set main preferences
          w_picked->setMainPreferences(prefs_);
          String new_name = w2->widget()->canvas()->getCurrentLayer().name+"(picked)";

          Spectrum2DCanvas::ExperimentType& exp2 = w_picked->widget()->canvas()->addEmptyPeakLayer();

          String filename = w2->widget()->canvas()->getCurrentLayer().name+"_picked";

          peak_picker.pickExperiment(w2->widget()->canvas()->getCurrentPeakData(),exp2);

          w_picked->widget()->canvas()->finishAdding();
          w_picked->widget()->canvas()->setCurrentLayerName(new_name);

          connectWindowSignals_(w_picked);
          w_picked->setCaption(new_name.c_str());
          addClient(w_picked,filename);
          addTab_(w_picked,new_name);

          w_picked->showMaximized();
        }
      }
      updateLayerbar();
    }
  }

  SpectrumWindow*  TOPPViewBase::activeWindow_() const
  {
    return dynamic_cast<SpectrumWindow*>(ws_->activeWindow());
  }

  SpectrumCanvas*  TOPPViewBase::activeCanvas_() const
  {
    SpectrumWindow* sw = dynamic_cast<SpectrumWindow*>(ws_->activeWindow());
    if (sw == 0)
    {
    	return 0;
    }
    return sw->widget()->canvas();
  }

  Spectrum1DWindow* TOPPViewBase::active1DWindow_() const
  {
    Spectrum1DWindow* s1;
    if ((s1 = dynamic_cast<Spectrum1DWindow*>(ws_->activeWindow())))
    {
      return s1;
    }
    return 0;
  }

  Spectrum2DWindow* TOPPViewBase::active2DWindow_() const
  {
    Spectrum2DWindow* s2;
    if ((s2 = dynamic_cast<Spectrum2DWindow*>(ws_->activeWindow())))
    {
      return s2;
    }
    return 0;
  }

  Spectrum3DWindow* TOPPViewBase::active3DWindow_() const
  {
    Spectrum3DWindow* s3;
    if ((s3 = dynamic_cast<Spectrum3DWindow*>(ws_->activeWindow())))
    {
      return s3;
    }
    return 0;
  }

  PreferencesDialogPage* TOPPViewBase::createPreferences(QWidget* parent)
  {
    return new TOPPViewBasePDP(this,parent);
  }

  void TOPPViewBase::loadPreferences(string filename)
  {
    //compose default ini file path
    String default_ini_file;
    char * home;
    home = getenv ("HOME");
    if (home!=NULL)
    {
      default_ini_file = home;
      default_ini_file = default_ini_file + "/";
    }
    default_ini_file = default_ini_file + ".TOPPView.ini";

    if (filename=="")
    {
      filename = default_ini_file;
    }
    prefs_.setValue("PreferencesFile" , filename);

    //load preferences, if file exists
    FILE * infile;
    infile = fopen (filename.c_str(), "r");
    if (infile != NULL)
    {
      prefs_.clear();
      prefs_.setValue("PreferencesFile" , filename);
      prefs_.load(filename);
    }
    else
    {
      if (filename != default_ini_file)
      {
        cerr << "Unable to load INI File: '" << filename << "'" << endl;
      }
      close (infile);
    }

    //set missing defaults
    checkPreferences_();

    //set the recent files
    Param p = prefs_.copy("Preferences:RecentFiles");
    if (p.size()!=0)
    {
      for (Param::ConstIterator it=p.begin() ; it!=p.end() ; ++it)
      {
        recent_files_.push_back(string(it->second));
      }
    }

    updateRecentMenu_();
  }

  void TOPPViewBase::savePreferences()
  {
    // replace recent files
    prefs_.remove("Preferences:RecentFiles");

    for (UnsignedInt i=0; i<recent_files_.size(); ++i)
    {
      prefs_.setValue("Preferences:RecentFiles:"+String(i),recent_files_[i]);
    }

    //save only the subsection that begins with "Preferences:"
    try
    {
      prefs_.copy("Preferences:").store(string(prefs_.getValue("PreferencesFile")));
    }
    catch(Exception::UnableToCreateFile& e)
    {
      cerr << "Unable to create INI File: '" << string(prefs_.getValue("PreferencesFile")) << "'" << endl;
    }
  }

  void TOPPViewBase::checkPreferences_()
  {
    Param default_preferences;

    //general
    default_preferences.setValue("DB:Host", "localhost");
    default_preferences.setValue("DB:Login", "NoName");
    default_preferences.setValue("DB:Name", "OpenMS");
    default_preferences.setValue("DB:Port", "3306");
    default_preferences.setValue("DefaultMapView", "2D");
    default_preferences.setValue("DefaultPath", ".");
    default_preferences.setValue("NumberOfRecentFiles", 15);
    default_preferences.setValue("Legend", "Hide");
    default_preferences.setValue("MapIntensityCutoff", "None");

    //1d
    default_preferences.setValue("1D:HighColor", "#ff0000");
    default_preferences.setValue("1D:IconColor", "#000000");
    default_preferences.setValue("1D:PeakColor", "#0000ff");
    default_preferences.setValue("1D:BackgroundColor", "#ffffff");
    default_preferences.setValue("1D:Mapping:MappingOfMzTo","X-Axis");

    //2d
    default_preferences.setValue("2D:BackgroundColor", "#ffffff");
    default_preferences.setValue("2D:MarchingSquaresSteps", 20);
    default_preferences.setValue("2D:InterpolationSteps", 200);
    default_preferences.setValue("2D:Dot:Gradient", "Linear|0,#ffff00;11,#ffaa00;32,#ff0000;55,#aa00ff;78,#5500ff;100,#000000");
    default_preferences.setValue("2D:Dot:Mode", 1);
    default_preferences.setValue("2D:Surface:Gradient", "Linear|0,#ffffff;22,#fdffcb;50,#ffb4b4;75,#d7cfff;100,#c1c1c1");
    default_preferences.setValue("2D:Contour:Lines", 8);
    default_preferences.setValue("2D:Mapping:MappingOfMzTo","X-Axis");

    //3d
    default_preferences.setValue("3D:Dot:Mode", 1);
    default_preferences.setValue("3D:Shade:Mode", 1);
    default_preferences.setValue("3D:Dot:Gradient", "Linear|0,#ffff00;11,#ffaa00;32,#ff0000;55,#aa00ff;78,#5500ff;100,#000000");
    default_preferences.setValue("3D:Dot:InterpolationSteps",200);
    default_preferences.setValue("3D:BackgroundColor", "#ffffff");
    default_preferences.setValue("3D:AxesColor", "#000000");
    default_preferences.setValue("3D:IntMode",0);
    default_preferences.setValue("3D:Dot:LineWidth",2);
    default_preferences.setValue("3D:IntScale:Mode",0);
		default_preferences.setValue("3D:Data:Mode",0);
		default_preferences.setValue("3D:Data:Reduction:Max",10);
		default_preferences.setValue("3D:Data:Reduction:Sum",10);
		default_preferences.setValue("3D:DisplayedPeaks",10000);
		default_preferences.setValue("3D:Reduction:Mode","MaxReduction");

    prefs_.setDefaults(default_preferences,"Preferences");
  }

  void TOPPViewBase::openRecentFile(int i)
  {
    setCursor(Qt::WaitCursor);
    OpenDialog::Mower mow = OpenDialog::NO_MOWER;
    if ( getPrefAsString("Preferences:MapIntensityCutoff")=="Noise Estimator")
    {
      mow = OpenDialog::NOISE_ESTIMATOR;
    }
    addSpectrum(recent_files_[i].c_str(),true,getPrefAsString("Preferences:DefaultMapView")=="2D",true,mow);
    setCursor(Qt::ArrowCursor);
  }

  void TOPPViewBase::findFeaturesActiveSpectrum()
  {
#ifdef CGAL_DEF
    Spectrum2DWindow* w = active2DWindow_();
    if (w!=0)
    {
      FeaFiDialog dialog(this, "FeaFiDialog");
      if (dialog.exec() == QDialog::Accepted)
      {
        //find features
        FeatureFinder& finder = dialog.getFeatureFinder();
        
        finder.setData(w->widget()->canvas()->getCurrentPeakData().begin(),w->widget()->canvas()->getCurrentPeakData().end(),1500);
        DFeatureMap<2> map = finder.run();

        //display features
        w->widget()->canvas()->addLayer(map,false);
        w->widget()->canvas()->setCurrentLayerName(w->widget()->canvas()->getCurrentLayer().name+" (features)");
        updateLayerbar();
      }
    }
#endif
  }

  void TOPPViewBase::closeEvent(QCloseEvent * e)
  {
    savePreferences();
    e->accept();
  }

  void TOPPViewBase::windowClosed()
  {
    // close tab bar, when last window is closed
    if (ws_->windowList().count()==1)
    {
      layer_bar_->hide();
    }
  }


  void TOPPViewBase::openSpectrumDialog()
  {
    OpenDialog dialog(prefs_,this,"Open Spectrum Dialog");
    if (dialog.exec())
    {
      //Open Files
      setCursor(Qt::WaitCursor);
      if (dialog.getSource()==OpenDialog::FILE)
      {
        for(vector<String>::const_iterator it=dialog.getNames().begin();it!=dialog.getNames().end();it++)
        {
          addSpectrum(*it,dialog.isOpenAsNewTab(),dialog.isViewMaps2D(),true,dialog.getMower(),dialog.forcedFileType());
        }
      }
      else
        // Open from DB
      {
        for(vector<String>::const_iterator it=dialog.getNames().begin();it!=dialog.getNames().end();it++)
        {
          addDBSpectrum(it->toInt(),dialog.isOpenAsNewTab(),dialog.isViewMaps2D(),true,dialog.getMower());
        }
      }
      setCursor(Qt::ArrowCursor);
      maximizeActiveSpectrum();
    }
  }

} //namespace OpenMS

