// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2009 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Andreas Bertsch $
// $Authors: Andreas Bertsch $
// --------------------------------------------------------------------------

#include <OpenMS/CHEMISTRY/TheoreticalSpectrumGenerator.h>
#include <OpenMS/DATASTRUCTURES/Map.h>
#include <OpenMS/CHEMISTRY/IsotopeDistribution.h>
#include <OpenMS/CONCEPT/Exception.h>
#include <OpenMS/CONCEPT/Constants.h>
#include <OpenMS/CHEMISTRY/AASequence.h>

using namespace std;

namespace OpenMS
{

	TheoreticalSpectrumGenerator::TheoreticalSpectrumGenerator()
		:	DefaultParamHandler("TheoreticalSpectrumGenerator")
	{
		defaults_.setValue("add_isotopes", 0, "If set to 1 isotope peaks of the product ion peaks are added");
		defaults_.setValue("max_isotope", 2, "Defines the maximal isotopic peak which is added, add_isotopes must be set to 1");
		defaults_.setValue("add_metainfo", 0, "Adds the type of peaks as metainfo to the peaks, like y8+, [M-H2O+2H]++");
		defaults_.setValue("add_losses", 0, "Adds common losses to those ion expect to have them, only water and ammonia loss is considered");
		defaults_.setValue("add_precursor_peaks", 0, "Adds peaks of the precursor to the spectrum, which happen to occur sometimes");

		// intensity options of the ions
		defaults_.setValue("y_intensity", 1.0, "Intensity of the y-ions");
		defaults_.setValue("b_intensity", 1.0, "Intensity of the b-ions");
		defaults_.setValue("a_intensity", 1.0, "Intensity of the a-ions");
		defaults_.setValue("c_intensity", 1.0, "Intensity of the c-ions");
		defaults_.setValue("x_intensity", 1.0, "Intensity of the x-ions");
		defaults_.setValue("z_intensity", 1.0, "Intensity of the z-ions");

		defaults_.setValue("relative_loss_intensity", 0.1, "Intensity of loss ions, in relation to the intact ion intensity");

		// precursor intensity
		defaults_.setValue("precursor_intensity", 1.0, "Intensity of the precursor peak");
		defaults_.setValue("precursor_H2O_intensity", 1.0, "Intensity of the H2O loss peak of the precursor");
		defaults_.setValue("precursor_NH3_intensity", 1.0, "Intensity of the NH3 loss peak of the precursor");

		defaultsToParam_();

		// just in case someone wants the ion names;
		p_.metaRegistry().registerName("IonName", "Name of the ion");
	}

	TheoreticalSpectrumGenerator::TheoreticalSpectrumGenerator(const TheoreticalSpectrumGenerator& rhs)
		: DefaultParamHandler(rhs)
	{
	}

	TheoreticalSpectrumGenerator& TheoreticalSpectrumGenerator::operator = (const TheoreticalSpectrumGenerator& rhs)
	{
		if (this != &rhs)
		{
			DefaultParamHandler::operator=(rhs);
		}
		return *this;
	}

	TheoreticalSpectrumGenerator::~TheoreticalSpectrumGenerator()
	{
	}

	void TheoreticalSpectrumGenerator::getSpectrum(RichPeakSpectrum& spec, const AASequence& peptide, Int charge)
	{
		if(peptide.size()==0)
		{
			return;
		}

		for (Int z = 1; z <= charge; ++z)
		{
			addPeaks(spec, peptide, Residue::BIon, z);
			addPeaks(spec, peptide, Residue::YIon, z);
		}

		bool add_precursor_peaks((int)param_.getValue("add_precursor_peaks"));
		if (add_precursor_peaks)
		{
			addPrecursorPeaks(spec, peptide, charge);
		}
		return;
	}

	void TheoreticalSpectrumGenerator::getSpectrum(RichPeakSpectrum& spec, const AASequence& peptide, Int charge_lo, Int charge_hi)
	{
		if(peptide.size()==0 or charge_lo > charge_hi)
		{
			return;
		}

		for (Int z = charge_lo; z <= charge_hi; ++z)
		{
			addPeaks(spec, peptide, Residue::BIon, z);
			addPeaks(spec, peptide, Residue::YIon, z);
		}

		bool add_precursor_peaks((int)param_.getValue("add_precursor_peaks"));
		if (add_precursor_peaks)
		{
			for (Int z = charge_lo; z <= charge_hi; ++z)
			{
				addPrecursorPeaks(spec, peptide, z);
			}
		}
		return;
	}

	void TheoreticalSpectrumGenerator::addPeaks(RichPeakSpectrum& spectrum, const AASequence& peptide, Residue::ResidueType res_type, Int charge)
	{
		Map<DoubleReal, AASequence> ions;
		Map<DoubleReal, String> names;
		AASequence ion;
		DoubleReal intensity(0);

		if(peptide.size()>0)
		{
			// generate the ion peaks
			switch(res_type)
			{
				case Residue::AIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getPrefix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::AIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "a"+String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("a_intensity");
					break;

				case Residue::BIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getPrefix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::BIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "b"+String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("b_intensity");
					break;

				case Residue::CIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getPrefix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::CIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "c"+String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("c_intensity");
					break;

				case Residue::XIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getSuffix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::XIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "x"+String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("x_intensity");
					break;

				case Residue::YIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getSuffix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::YIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "y"+String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("y_intensity");
					break;

				case Residue::ZIon:
					for (Size i = 1; i != peptide.size(); ++i)
					{
						ion = peptide.getSuffix(i);
						DoubleReal pos = ion.getMonoWeight(Residue::ZIon, charge) / (DoubleReal)charge;
						ions[pos] = ion;
						names[pos] = "z" + String(i) + String(charge, '+');
					}
					intensity = (DoubleReal)param_.getValue("z_intensity");
					break;

				default:
					cerr << "Cannot create peaks of that ion type" << endl;
			}
		}
		else
		{
			throw Exception::InvalidParameter(__FILE__, __LINE__, __PRETTY_FUNCTION__, "given sequence is empty");
		}

		// get the params
		bool add_losses((int)param_.getValue("add_losses"));
		bool add_metainfo((int)param_.getValue("add_metainfo"));
		bool add_isotopes((int)param_.getValue("add_isotopes"));
		int max_isotope((int)param_.getValue("max_isotope"));
		DoubleReal rel_loss_intensity((DoubleReal)param_.getValue("relative_loss_intensity"));

		for (Map<DoubleReal, AASequence>::ConstIterator cit = ions.begin(); cit != ions.end(); ++cit)
		{
			ion = cit->second;
			DoubleReal pos = cit->first;
			String ion_name = names[pos];
			if (add_isotopes)
			{
				IsotopeDistribution dist = ion.getFormula(res_type, charge).getIsotopeDistribution(max_isotope);
				UInt j(0);
				for (IsotopeDistribution::ConstIterator it=dist.begin(); it!=dist.end(); ++it, ++j)
				{
					p_.setMZ((DoubleReal)(pos + (DoubleReal)j * Constants::NEUTRON_MASS_U)/(DoubleReal)charge);
					p_.setIntensity(intensity * it->second);
					if (add_metainfo && j == 0)
					{
						p_.setMetaValue("IonName", ion_name);
					}
					spectrum.push_back(p_);
				}
			}
			else
			{
				p_.setMZ(pos);
				p_.setIntensity(intensity);
				if (add_metainfo)
				{
					p_.setMetaValue("IonName", ion_name);
				}
				spectrum.push_back(p_);
			}

			if (add_losses)
			{
				set<String> losses;
				for (AASequence::ConstIterator it = cit->second.begin(); it != cit->second.end(); ++it)
				{
					if (it->hasNeutralLoss())
					{
						vector<EmpiricalFormula> loss_formulas = it->getLossFormulas();
						for (Size i = 0; i != loss_formulas.size(); ++i)
						{
							losses.insert(loss_formulas[i].getString());
						}
					}
				}


				if (!add_isotopes)
				{
					p_.setIntensity(intensity * rel_loss_intensity);
				}

				for (set<String>::const_iterator it=losses.begin(); it!=losses.end(); ++it)
				{
					EmpiricalFormula loss_ion = ion.getFormula(res_type, charge) - EmpiricalFormula(*it);
					// thanks to Chris and Sandro
					// check for negative element frequencies (might happen if losses are not allowed for specific ions)
					bool negative_elements(false);
					for (EmpiricalFormula::ConstIterator eit = loss_ion.begin(); eit != loss_ion.end(); ++eit)
					{
						if (eit->second < 0)
						{
							negative_elements = true;
							break;
						}
					}
					if (negative_elements)
					{
						continue;
					}
					DoubleReal loss_pos = loss_ion.getMonoWeight() / (DoubleReal)charge;
					String loss_name = *it;

					if (add_isotopes)
					{
						IsotopeDistribution dist = loss_ion.getIsotopeDistribution(max_isotope);
						UInt j(0);
						for (IsotopeDistribution::ConstIterator iso=dist.begin(); iso!=dist.end(); ++iso)
						{
							p_.setMZ((DoubleReal)(loss_pos + j) / (DoubleReal)charge);
							p_.setIntensity(intensity * rel_loss_intensity * iso->second);
							if (add_metainfo && j == 0)
							{
								p_.setMetaValue("IonName", ion_name + "-" + loss_name);
							}
							spectrum.push_back(p_);
						}
					}
					else
					{
						p_.setMZ(loss_pos);
						if (add_metainfo)
						{
							p_.setMetaValue("IonName", ion_name + "-" + loss_name);
						}
						spectrum.push_back(p_);
					}
				}
			}
		}

		if (add_metainfo)
		{
			p_.setMetaValue("IonName", String(""));
		}

		spectrum.sortByPosition();

		return;
	}


	void TheoreticalSpectrumGenerator::addPrecursorPeaks(RichPeakSpectrum& spec, const AASequence& peptide, Int charge)
	{
		bool add_metainfo((int)param_.getValue("add_metainfo"));
		DoubleReal pre_int((DoubleReal)param_.getValue("precursor_intensity"));
		DoubleReal pre_int_H2O((DoubleReal)param_.getValue("precursor_H2O_intensity"));
		DoubleReal pre_int_NH3((DoubleReal)param_.getValue("precursor_NH3_intensity"));
		bool add_isotopes((int)param_.getValue("add_isotopes"));
    //int max_isotope((int)param_.getValue("max_isotope"));

		if (add_isotopes)
		{
			// TODO
		}
		else
		{
			// precursor peak
			p_.setMZ(peptide.getMonoWeight(Residue::Full, charge)/DoubleReal(charge));
			p_.setIntensity(pre_int);
			if (add_metainfo)
			{
				String name("[M+H]+");
				if (charge == 2)
				{
					name = "[M+2H]++";
				}
				p_.setMetaValue("IonName", name);
			}

			spec.push_back(p_);

			// loss peaks of the precursor
			static const DoubleReal h2o_weight = EmpiricalFormula("H2O").getMonoWeight();
			p_.setMZ((peptide.getMonoWeight(Residue::Full, charge) - h2o_weight)/DoubleReal(charge));
			p_.setIntensity(pre_int_H2O);

			if (add_metainfo)
			{
				String name("[M+H]-H2O+");
				if (charge == 2)
				{
					name = "[M+2H]-H2O++";
				}
				p_.setMetaValue("IonName", name);
			}
			spec.push_back(p_);

			static const DoubleReal nh3_weight = EmpiricalFormula("NH3").getMonoWeight();
      p_.setMZ((peptide.getMonoWeight(Residue::Full, charge) - nh3_weight)/DoubleReal(charge));
      p_.setIntensity(pre_int_NH3);

      if (add_metainfo)
      {
        String name("[M+H]-NH3+");
        if (charge == 2)
        {
          name = "[M+2H]-NH3++";
        }
        p_.setMetaValue("IonName", name);
      }
      spec.push_back(p_);

		}

	}
}
