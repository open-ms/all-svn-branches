// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2008 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

#include <OpenMS/DATASTRUCTURES/String.h>
#include <OpenMS/DATASTRUCTURES/DataValue.h>

#include <cmath>
#include <cstdlib>
#include <iostream>
#include <sstream>
#include <limits>
#include <algorithm>
#include <QtCore/QString>

using namespace std;

namespace OpenMS
{
	const String String::EMPTY;

	String::String()
		:	string()
	{
	}

	String::String(const string& s)
		:	string(s)
	{
	}

	String::String(const char* s)
		: string(s)
	{
		
	}

	String::String(const QString& s)
		:	string(s.toStdString())
	{
	}

	String::String(const char* s, SizeType length)
	{
		SizeType count = 0;
		while(count < length && *(s+count)!=0)
		{
			*this += *(s+count);
			++count;
		}
	}

	String::String(const char c)
		:	string(1,c)
	{
	}

	String::String(size_t len, char c)
		:	string(len, c)
	{
	}

	String::String(int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(unsigned int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(short int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(short unsigned int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(long int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(long unsigned int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(long long unsigned int i)
		: string()
	{
		stringstream s;
		s << i;
		string::operator=(s.str());
	}

	String::String(float f)
		: string()
	{
		stringstream s;
		s.precision(writtenDigits(f));
		s << f;
		string::operator=(s.str());
	}

	String::String(double d)
		: string()
	{
		stringstream s;
		s.precision(writtenDigits(d));
		s << d;
		string::operator=(s.str());
	}

	String::String(long double ld)
		: string()
	{
		stringstream s;
		s.precision(writtenDigits(ld));
		s << ld;
		string::operator=(s.str());
	}
	
	String String::numberLength(DoubleReal d, UInt n)
	{
		stringstream s;
		//reserve one space for the minus sign
		Int sign=0;
		if (d<0) sign=1;
		d = fabs(d);
		
		if (d<pow(10.0,Int(n-sign-2)))
		{
			s.precision(writtenDigits(d)); // Note: Precision was formerly set to 10.  TODO: remove this comment.
			if (sign==1) s << "-";
			s << d;
		}
		else
		{
			UInt exp=0;
			while(d>pow(10.0,Int(n-sign-4)))
			{
				d/=10;
				++exp;
			}
			d = Int(d)/10.0;
			exp+=1;
			if (sign==1) s << "-";
			s << d<<"e";
			if (exp<10) s << "0";
			s <<exp; 
		}
		return s.str().substr(0,n);		
	}

	String String::number(DoubleReal d, UInt n)
	{
		return QString::number(d,'f',n);
	}

	String& String::fillLeft(char c, UInt size)
	{
		if (string::size()<size)
		{
			string::operator=(string(size-string::size(),c)+*this);
		}
		return *this;
	}

	String& String::fillRight(char c, UInt size)
	{
		if (string::size()<size)
		{
			string::operator=(*this+string(size-string::size(),c));
		}		
		return *this;
	}
	
	String::String(const DataValue& d)
		: string()
	{
		string::operator=(d.toString());
	}

	bool String::hasPrefix(const String& string) const
	{
		if (string.size() > size())
		{
			return false;
		}
		if (string.size() == 0)
		{
			return true;
		}
		return (compare(0, string.size(), string) == 0);
	}

	bool String::hasSuffix(const String& string) const
	{
		if (string.size() > size())
		{
			return false;
		}
		if (string.size() == 0)
		{
			return true;
		}
		return (compare(size()-string.size(), string.size(), string) == 0);
	}

	bool String::hasSubstring(const String& string) const
	{
		if (string.size() > size())
		{
			return false;
		}
		if (string.size() == 0)
		{
			return true;
		}
		for (UInt i=0;i!=size();++i)
		{
			if (compare(i, string.size(), string) == 0)
			{
				return true;
			}
		}
		return false;
	}

	bool String::has(Byte byte) const
	{
		for (UInt i=0;i!=size();++i)
		{
			if ((*this)[i] == byte)
			{
				return true;
			}
		}
		return false;
	}

	String String::prefix(SizeType length) const
	{
		if (length > size())
		{
			throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length, size());
		}
		return substr(0, length);
	}

	String String::suffix(SizeType length) const
	{
		if (length > size())
		{
			throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length, size());
		}
		return substr(size()-length, length);
	}

	String String::prefix(Int length) const
	{
		if (length < 0)
		{
			throw Exception::IndexUnderflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length,0);
		}
		if (length > Int(size()))
		{
			throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length, size());
		}
		return substr(0, length);
	}

	String String::suffix(Int length) const
	{
		if (length < 0)
		{
			throw Exception::IndexUnderflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length,0);
		}
		if (length > Int(size()))
		{
			throw Exception::IndexOverflow(__FILE__, __LINE__, __PRETTY_FUNCTION__, length, size());
		}
		return substr(size()-length, length);
	}

	String String::prefix(char delim) const
	{
		ConstIterator it=begin();
		while (it!=end() && *it!=delim)
		{
			++it;
		}
		//char not found
		if (it==end())
		{
			throw Exception::ElementNotFound(__FILE__, __LINE__, __PRETTY_FUNCTION__, String(delim));
		}
		return String(begin(), it);
	}

	String String::suffix(char delim) const
	{
		ConstIterator it=end();
		--it;
		while (it!=--(begin()) && *it!=delim)
		{
			--it;
		}
		//char not found
		if (it==--(begin()))
		{
			throw Exception::ElementNotFound(__FILE__, __LINE__, __PRETTY_FUNCTION__, String(delim));
		}
		++it;
		return String(it, end());
	}

	String String::substr(Int start, Int n) const
	{
		ConstIterator begin, end;
		if (start>=0)
		{
			begin = this->begin()+start;
		}
		else
		{
			begin = this->end()+start;
		}
		if (n>=0)
		{
			end = begin + n;
		}
		else
		{
			end = this->end()+n;
		}
		//prevent errors
		if (begin<this->begin())
		{
			begin = this->begin();
		}
		if (end>this->end())
		{
			end = this->end();
		}
		if (begin>end)
		{
			begin = end;
		}
		return String(begin,end);
		
	}

	String String::substr(Int start) const
	{
		ConstIterator begin;
		if (start>=0)
		{
			begin = this->begin()+start;
		}
		else
		{
			begin = this->end()+start;
		}
		//prevent errors
		if (begin<this->begin())
		{
			begin = this->begin();
		}
		if (begin>this->end())
		{
			begin = this->end();
		}
		return String(begin,this->end());
	}

	String& String::trim()
	{
		//search for the begin of truncated string
		iterator begin = this->begin();
		while (begin!=end() && (*begin==' ' || *begin=='\t' || *begin=='\n'  || *begin=='\r' ))
		{
			++begin;
		}
		
		//all characters are whitespaces
		if (begin==end())
		{
			string::clear();
			return *this;
		}
		
		//search for the end of truncated string
		Iterator end=this->end();
		end--;
		while (end!=begin && (*end==' ' || *end=='\n' || *end=='\t' || *end=='\r' ))
		{
			--end;
		}
		++end;

		//no characters are whitespaces
		if (begin==this->begin() && end==this->end())
		{
			return *this;
		}
		
		string::operator=(string(begin,end));
		return *this;
	}

	String& String::simplify()
	{
		String simple;
		
		bool last_was_whitespace = false;
		for (iterator it = this->begin(); it!=end(); ++it)
		{
			if (*it==' ' || *it=='\n' || *it=='\t' || *it=='\r')
			{
				if (!last_was_whitespace)
				{
					simple += ' ';
				}
				last_was_whitespace = true;
			}
			else
			{
				simple += *it;
				last_was_whitespace = false;
			}
		}
		
		string::operator=(simple);
		
		return *this;
	}

	String String::random(UInt length)
	{
		srand(time(0));
		String tmp(length, '.');
		UInt random;
		for (UInt i = 0 ; i < length; ++i)
		{
			random = (SizeType)floor(((double)rand()/(double(RAND_MAX)+1)) * 62.0);
			if (random < 10)
			{
				tmp[i] = (char)(random +48);
			}
			else if (random < 36)
			{
				tmp[i] = (char)(random +55);
			}
			else
			{
				tmp[i] = (char)(random +61);
			}
		}
		return tmp;
	}

	String& String::reverse()
	{
		String tmp = *this;
		for (UInt i=0;i!=size();++i)
		{
			(*this)[i] = tmp[size()-1-i];
		}
		return *this;
	}

	bool String::split(char splitter, std::vector<String>& substrings) const
	{
		Int parts = count(this->begin(),this->end(),splitter);
		
		// no splitter found
		if (parts == 0)
		{
			substrings.clear();
			return false;
		}
		
		// splitter(s) found
		substrings.resize(parts+1);		
		
		ConstIterator end = this->begin();
		ConstIterator begin = this->begin();		
		
		parts=0;
		
		for (; end != this->end(); ++end)
		{
			if (*end == splitter)
			{
				substrings[parts++] = String(begin,end);
				begin = end+1;
			}
		}
		substrings[parts] = String(begin,end);
		
		return true;
	}

	QString String::toQString() const
	{
		return QString(this->c_str());
	}

	Int String::toInt() const
	{
    std::stringstream ss(c_str());
    Int ret = 0;
    if (!(ss >> ret)) throw Exception::ConversionError(__FILE__, __LINE__, __PRETTY_FUNCTION__, String("Could not convert string '")+*this+"' to an integer value");
    return ret;
	}

	Real String::toFloat() const
	{
    std::stringstream ss(c_str());
    Real ret;
    if (!(ss >> ret)) throw Exception::ConversionError(__FILE__, __LINE__, __PRETTY_FUNCTION__,  String("Could not convert string '")+*this+"' to a float value");
    return ret;    
	}

	DoubleReal String::toDouble() const
	{
    std::stringstream ss(c_str());
    DoubleReal ret;
    if (!(ss >> ret)) throw Exception::ConversionError(__FILE__, __LINE__, __PRETTY_FUNCTION__,  String("Could not convert string '")+*this+"' to a double value");
    return ret;    
	}

	String& String::toUpper()
	{
		std::transform(this->begin(), this->end(), this->begin(), (int(*)(int)) toupper);
		return *this;
	}

	String& String::firstToUpper()
	{
		if (this->size()!=0)
		{
			(*this)[0] = toupper ((*this)[0]);
		}
		return *this;
	}

	String& String::toLower()
	{
		std::transform(this->begin(), this->end(), this->begin(), (int(*)(int)) tolower);
		return *this;
	}
	
	String& String::substitute(char from, char to)
	{
		std::replace(this->begin(), this->end(), from, to);
		return *this;
	}

	String& String::substitute(const String& from, const String& to)
	{
		if (!from.empty())
		{
			if (to.hasSubstring(from))
			{
				cerr << "Warning: String::substitute 'to' (" << to <<") many not contain 'from' (" << from <<"). Aborting!" << endl;
				return *this;
			}

	   	string::size_type loc = this->find(from, 0);
	   	while( loc != string::npos ) 
	   	{
				this->replace(loc, from.size(), to);
				loc = this->find(from, 0);
			}
		}
		
		return *this;
	}

	String& String::remove(char what)
	{
		this->erase(std::remove(this->begin(), this->end(), what),this->end());
		return *this;
	}

	String& String::ensureLastChar(char end)
	{
		if ( !this->hasSuffix(end) ) this->append(1, end);
		return *this;
	}

	String& String::removeWhitespaces()
	{
		Iterator end = this->end();
		end  = std::remove(this->begin(), end, ' ');
		end  = std::remove(this->begin(), end, '\t');
		end  = std::remove(this->begin(), end, '\n');
		end  = std::remove(this->begin(), end, '\r');
				
		this->erase(end,this->end());
		return *this;
	}

	String String::operator+ (int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (unsigned int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (short int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (short unsigned int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (long int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (long unsigned int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (long long unsigned int i) const
	{
		stringstream s;
		s << *this << i;
		return s.str();
	}

	String String::operator+ (float f) const
	{
		stringstream s;
		s.precision(writtenDigits(f));
		s << *this << f;
		return s.str();
	}

	String String::operator+ (double d) const
	{
		stringstream s;
		s.precision(writtenDigits(d));
		s << *this << d;
		return s.str();
	}

	String String::operator+ (long double ld) const
	{
		stringstream s;
		s.precision(writtenDigits(ld));
		s << *this << ld;
		return s.str();
	}

	String String::operator+ (char c) const
	{
		String tmp(*this);
		tmp.push_back(c);
		return tmp;
	}

	String String::operator+ (const char* s) const
	{
		String tmp(*this);
		tmp.append(s);
		return tmp;
	}

		String String::operator+ (const String& s) const
	{
		String tmp(*this);
		tmp.insert(tmp.end(),s.begin(),s.end());
		return tmp;
	}
		
		String String::operator+ (const std::string& s) const
	{
		String tmp(*this);
		tmp.insert(tmp.end(),s.begin(),s.end());
		return tmp;
	}

	String& String::operator+= (int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (unsigned int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (short int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (short unsigned int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (long int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (long unsigned int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (long long unsigned int i)
	{
		this->append(String(i));
		return *this;
	}

	String& String::operator+= (float f)
	{
		this->append(String(f));
		return *this;
	}

	String& String::operator+= (double d)
	{
		this->append(String(d));
		return *this;
	}

	String& String::operator+= (long double d)
	{
		this->append(String(d));
		return *this;
	}

	String& String::operator+= (char c)
	{
		this->append(String(c));
		return *this;
	}

	String& String::operator+= (const char* s)
	{
		this->append(s);
		return *this;
	}

	String& String::operator+= (const String& s)
	{
		this->append(s);
		return *this;
	}
		
	String& String::operator+= (const std::string& s)
	{
		this->append(s);
		return *this;
	}

} // namespace OpenMS


