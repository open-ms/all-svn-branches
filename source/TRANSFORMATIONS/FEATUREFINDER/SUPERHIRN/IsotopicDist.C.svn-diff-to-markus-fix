Index: IsotopicDist.C
===================================================================
--- IsotopicDist.C	(revision 8280)
+++ IsotopicDist.C	(working copy)
@@ -658,7 +658,7 @@
       if (sfIsoDist50[i][j]<max_intens*fact && j>1) break;
     }
 		
-    sfNrIsotopes[i] = j; 
+    sfNrIsotopes[i] = j;
   } 
 }
 
@@ -726,7 +726,9 @@
   pAlpha = (intens + pTheta) / theoIntensMono;
 
   
-  int maxNbIsotopes = sfNrIsotopes[idx];
+  // Markus-Fix, applied 2011-05-06
+  int maxNbIsotopes = sfNrIsotopes[idx]; // number of isotopes used for quantification
+  int maxMaxNbIsotopes = (maxNbIsotopes>6)?maxNbIsotopes:6; // number of isotopes to be removed
   
   /*
   if( CentroidData::MonoIsoDebugging ){
@@ -741,7 +743,7 @@
   
   
   
-  for (i=0;i<maxNbIsotopes;i++) { // find matching isotopes
+  for (i=0;i<maxMaxNbIsotopes;i++) { // find matching isotopes
     theta = (sfIsoDist50Local[i]<IsotopicDist::sfDetectableIsoFact)?pTheta:0.0; // this only requires intense isotpic peaks to match exp. peaks
     
     //m_low = mono + sfIsoDist10Local[i]/pCharge - tol;
@@ -816,6 +818,127 @@
       }
     }
     
+    
+    if (i<maxNbIsotopes) alpha_values.push_back(max_alpha);
+    //if (i<maxNbIsotopes && sfDebug) sfStream << i << ":" << max_alpha << " ";	
+    
+//    if (max_alpha < 1.0) break;
+  } 
+  
+  // calculate final alpha
+  pAlpha = 0.0;
+  min_alpha = *(alpha_values.begin());
+  cnt = 0;
+  matched = true; 
+  for (avi=alpha_values.begin();avi!=alpha_values.end();++avi) {
+    if (abs(*avi-mono_alpha)/mono_alpha < IsotopicDist::sfIntensityCV) { // alpha close to value from first isotope 
+      pAlpha += *avi;
+      cnt++;
+    } else if ((mono_alpha-*avi)/mono_alpha > IsotopicDist::sfIntensityCV) { // small alpha in case of missing peak
+      min_alpha = (min_alpha>*avi)?*avi:min_alpha;
+      matched = false;
+    } 
+  }
+  
+  if (matched) {
+    pAlpha /= cnt; // calculate the avg alpha values for all alphas close to the one of the monoisotopic peak
+  } else {
+    pAlpha = min_alpha; // otherwise take smallest
+  }
+  
+//if (sfDebug) sfStream << " " << pAlpha << endl;	
+  
+  return (pAlpha>1.0);
+}
+
+
+
+/*
+// OLD PEAK EXTRACTION ROUTINE FROM MARKUS, FOR BACKUP REASONSâ€¦ LUKAS 30.6.2008
+
+// Iterates over an list of CentroidPeak objects and finds those ones that match a isotopic m/z value. It also calculates the 'best' 
+// match of a isotopic pattern to these peaks. 
+bool IsotopicDist::getMatchingPeaks(
+                                    list<CentroidPeak>::iterator pMono, // potential monoisotopic peak 
+                                    list<CentroidPeak>::iterator pEnd, // end of peak group
+                                    int pCharge, // charge of the isotopic pattern 
+                                    double& pAlpha, // best fit factor
+                                    double pTheta, // noise level
+                                    list<list<CentroidPeak>::iterator>& pMatchedPeaks) // matching peaks
+{
+  int idx,i,cnt;
+  double m_low,m_high,tol,m,alpha,max_alpha,min_alpha,mono_alpha,mono,theta,dm,dist,dist_min;
+  bool matched;
+  list<CentroidPeak>::iterator piter,match_peak;
+  list<double> alpha_values;
+  list<double>::iterator avi;
+  
+  mono = pMono->getMass();
+  tol =  CentroidData::sfMassTolPpm*mono/1.0e6 +  CentroidData::sfMassTolDa;
+  piter = pMono;
+  mono_alpha = 0.0;
+  
+  if (sfDebug) (*cout) << fixed << setprecision(4) << mono << " " ;	
+  
+  
+  idx = getIndex(mono,pCharge);
+  
+  pAlpha = (pMono->getIntensity()+pTheta)/sfIsoDist50[idx][0];
+  for (i=0;i<sfNrIsotopes[idx];i++) { // find matching isotopes
+    theta = (sfIsoDist50[idx][i]<IsotopicDist::sfDetectableIsoFact)?pTheta:0.0; // this only requires intense isotpic peaks to match exp. peaks
+    
+    m_low = mono + sfIsoMass10[idx][i]/pCharge - tol;
+    m_high = mono + sfIsoMass90[idx][i]/pCharge + tol;
+    
+    matched = false;
+    dist_min = 100.0;
+    dm = 1.0;
+    max_alpha = 0.0;
+    for (;piter!=pEnd;++piter) {
+      m = piter->getMass();
+      
+      if (m>=m_low && m<=m_high) { // matching mass
+        dm = abs(piter->getMass()-mono-sfIsoMass50[idx][i]/pCharge);				
+        alpha = (piter->getIntensity()+theta)/sfIsoDist50[idx][i];
+        if (i>0) { // second and higher isotop
+          dist = abs((alpha-mono_alpha)/mono_alpha) + 10.0*dm/tol; // score to evaluate distance between expected and measured values 
+          if (dist<dist_min) { // take minimum distance within same isotop mass range
+            max_alpha = alpha; 
+            match_peak = piter;
+            match_peak->setIsotopIdx(i);
+            dist_min = dist;
+            matched = true; 
+          }					
+        } else { // fist (C12) isotop
+          if (piter == pMono) { 
+            mono_alpha = alpha; // take only peak itself within C12 isotop mass range
+            max_alpha = alpha;
+            match_peak = pMono;
+            pMono->setIsotopIdx(0);
+            matched = true; 
+          }
+        }
+      }
+      else if (m>m_high) { // out of mass bounds: go to next isotope
+        if (!matched) {
+          alpha = theta/sfIsoDist50[idx][i];
+          max_alpha = (alpha>max_alpha)?alpha:max_alpha; // take maximum within same isotop
+        }
+        break;
+      }
+    }
+    
+    if (matched) {
+      pMatchedPeaks.push_back(match_peak);
+    }
+    
+    if (piter==pEnd) { // stop if no peaks are left
+      if (!matched) {
+        alpha = theta/sfIsoDist50[idx][i];
+        max_alpha = (alpha>max_alpha)?alpha:max_alpha; // take maximum within same isotop
+      }
+    }
+    
     alpha_values.push_back(max_alpha);
     if (sfDebug) (*sfStream) << i << ":" << max_alpha << " ";	
     
@@ -848,6 +971,7 @@
   return (pAlpha>1.0);
 }
 
+*/
 
 // Subtracts fitted isotopic distribution from the spectrum and defines monoisotopic peak
 void IsotopicDist::subtractMatchingPeaks(
