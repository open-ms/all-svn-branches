// -*- Mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework 
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2008 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Marc Sturm $
// --------------------------------------------------------------------------

// OpenMS
#include <OpenMS/VISUAL/SpectrumCanvas.h>
#include <OpenMS/VISUAL/SpectrumWidget.h>
#include <OpenMS/VISUAL/AxisWidget.h>
#include <OpenMS/SYSTEM/FileWatcher.h>
#include <OpenMS/VISUAL/MSMetaDataExplorer.h>

// QT
#include <QtGui/QPainter>
#include <QtGui/QPaintEvent>
#include <QtGui/QBitmap>
#include <QtGui/QWheelEvent>
#include <QtGui/QMessageBox>
#include <QtGui/QPushButton>

//Icons
#include "../VISUAL/ICONS/cursor_measure.xpm"
#include "../VISUAL/ICONS/cursor_zoom.xpm"
#include "../VISUAL/ICONS/cursor_move.xpm"

using namespace std;

namespace OpenMS
{	
	SpectrumCanvas::SpectrumCanvas(const Param& /*preferences*/, QWidget* parent)
		: QWidget(parent),
			DefaultParamHandler("SpectrumCanvas"),
			buffer_(),
			action_mode_(AM_TRANSLATE),
			intensity_mode_(IM_NONE),
			layers_(),
			mz_to_x_axis_(true),
			is_flipped_vertically_(false),
			visible_area_(AreaType::empty),
			overall_data_range_(DRange<3>::empty),
			show_grid_(true),
			zoom_stack_(),
			zoom_pos_(zoom_stack_.end()),
			update_buffer_(false),
			current_layer_(0),
			spectrum_widget_(0),
			percentage_factor_(1.0),
			snap_factor_(1.0),
			rubber_band_(QRubberBand::Rectangle,this),
			watcher_(0),
			context_add_(0)
	{		
		//Prevent filling background
		setAttribute(Qt::WA_OpaquePaintEvent);
		// get mouse coordinates while mouse moves over diagramm and for focus handling
		setMouseTracking(TRUE);
		setFocusPolicy(Qt::StrongFocus);
			
		setMinimumSize(200,200);
		setSizePolicy(QSizePolicy::MinimumExpanding,QSizePolicy::MinimumExpanding);
	  
	  //reserve enough space to avoid copying layer data
	  layers_.reserve(10);
	  
	  //set common defaults for all canvases
    defaults_.setValue("default_path", ".", "Default path for loading/storing data.");
    defaults_.setValue("on_file_change", "ask", "What action to take, when a data file changes. Do nothing, update autmatically or aks the user.");
    defaults_.setValidStrings("on_file_change",StringList::create("none,ask,update automatically"));
    
    //create file system watcher
    watcher_ = new FileWatcher(this);
    connect(watcher_,SIGNAL(fileChanged(const String&)),this,SLOT(fileChanged_(const String&)));
    
    //Set focus policy in order to get keyboard events
	  
	  
	  //Set 'whats this' text
	  setWhatsThis("Translate: Translate mode is activated by default. Hold down the left mouse key and move the mouse to translate. Arrow keys can be used for translation independent of the current mode.\n\n"
	  						 "Zoom: Zoom mode is activated with the CTRL key. CTRL+/CTRL- are used to traverse the zoom stack (or mouse wheel). Pressing Backspace resets the zoom.\n\n"
	  						 "Measure: Measure mode is activated with the SHIFT key. To measure the distace between data points, press the left mouse button on a point and drag the mouse to another point.\n\n"
								 );
		
		//set move cursor and connect signal that updates the cursor automatically
		updateCursor_();
		connect(this,SIGNAL(actionModeChange()),this,SLOT(updateCursor_()));
	}

	SpectrumCanvas::~SpectrumCanvas()
	{
		//cout << "DEST SpectrumCanvas" << endl;
	}

	void SpectrumCanvas::resizeEvent(QResizeEvent* /* e */)
	{
#ifdef DEBUG_TOPPVIEW
		cout << "BEGIN " << __PRETTY_FUNCTION__ << endl;
#endif
		buffer_ = QPixmap(width(), height());
		update_buffer_ = true;
		updateScrollbars_();
		update_(__PRETTY_FUNCTION__);
#ifdef DEBUG_TOPPVIEW
		cout << "END   " << __PRETTY_FUNCTION__ << endl;
#endif
	}

	void SpectrumCanvas::setFilters(const DataFilters& filters)
	{
		//set filters
		layers_[current_layer_].filters = filters;
		//update the content
		update_buffer_ = true;
		update_(__PRETTY_FUNCTION__);
	}
	
	void SpectrumCanvas::showGridLines(bool show)
	{
		show_grid_ = show;
		update_buffer_ = true;
		update_(__PRETTY_FUNCTION__);
	}
	
	void SpectrumCanvas::intensityModeChange_()
	{
		recalculateSnapFactor_();
		update_buffer_ = true;
		update_(__PRETTY_FUNCTION__);
	}

	bool SpectrumCanvas::isMzToXAxis() 
	{ 
		return mz_to_x_axis_; 
	}
	
	void SpectrumCanvas::mzToXAxis(bool mz_to_x_axis)
	{
		mz_to_x_axis_ = mz_to_x_axis;
		
		//swap axes if necessary
		if (spectrum_widget_)
		{
			spectrum_widget_->updateAxes();
		}
		
		updateScrollbars_();
		update_buffer_ = true;
		update_(__PRETTY_FUNCTION__);
	}
	
	bool SpectrumCanvas::isFlippedVertically() const
	{
		return is_flipped_vertically_;
	}
	
	void SpectrumCanvas::setFlippedVertically(bool is_flipped_vertically)
	{
		is_flipped_vertically_ = is_flipped_vertically;
	}
	
	void SpectrumCanvas::changeVisibleArea_(const AreaType& new_area, bool repaint, bool add_to_stack)
	{
		//store old zoom state
		if (add_to_stack)
		{
			zoomAdd_(new_area);
		}
		
		if (new_area!=visible_area_)
		{
			visible_area_ = new_area;
			updateScrollbars_();
			emit visibleAreaChanged(new_area);
		}

		if (repaint)
		{
			update_buffer_ = true;
			update_(__PRETTY_FUNCTION__);
		}
	}
	
	void SpectrumCanvas::updateScrollbars_()
	{
		
	}

	void SpectrumCanvas::wheelEvent(QWheelEvent* e)
	{
		if (e->delta() > 0)
		{
			zoomForward_();
		}
		else
		{
			zoomBack_();
		}
		e->accept();
	}
	
	void SpectrumCanvas::zoomBack_()
	{
		//cout << "Zoom out" << endl;
		//cout << " - pos before:" << (zoom_pos_-zoom_stack_.begin()) << endl;
		//cout << " - size before:" << zoom_stack_.size() << endl;
		if (zoom_pos_!=zoom_stack_.begin())
		{
			--zoom_pos_;
			changeVisibleArea_(*zoom_pos_);
		}
		//cout << " - pos after:" << (zoom_pos_-zoom_stack_.begin()) << endl;
	}

	void SpectrumCanvas::zoomForward_()
	{
		//cout << "Zoom in" << endl;
		//cout << " - pos before:" << (zoom_pos_-zoom_stack_.begin()) << endl;
		//cout << " - size before:" << zoom_stack_.size() <<endl;
		if (zoom_pos_!=zoom_stack_.end() && (zoom_pos_+1)!=zoom_stack_.end())
		{
			++zoom_pos_;
			changeVisibleArea_(*zoom_pos_);
		}
		//cout << " - pos after:" << (zoom_pos_-zoom_stack_.begin()) << endl;
	}
	
	void SpectrumCanvas::zoomAdd_(const AreaType& area)
	{
		//cout << "Adding to stack" << endl;
		//cout << " - pos before:" << (zoom_pos_-zoom_stack_.begin()) << endl;
		//cout << " - size before:" << zoom_stack_.size() <<endl;
		if (zoom_pos_!=zoom_stack_.end() && (zoom_pos_+1)!=zoom_stack_.end())
		{
			//cout << " - removing from:" << ((zoom_pos_+1)-zoom_stack_.begin()) << endl;
			zoom_stack_.erase(zoom_pos_+1,zoom_stack_.end());
		}
		zoom_stack_.push_back(area);
		zoom_pos_ = zoom_stack_.end();
		--zoom_pos_;
		//cout << " - pos after:" << (zoom_pos_-zoom_stack_.begin()) << endl;
		//cout << " - size after:" << zoom_stack_.size() <<endl;
	}
	
	void SpectrumCanvas::zoomClear_()
	{
		zoom_stack_.clear();
		zoom_pos_ = zoom_stack_.end();
	}
	
	void SpectrumCanvas::resetZoom(bool repaint)
	{
		zoomClear_();
		AreaType tmp;
		tmp.assign(overall_data_range_);
		changeVisibleArea_(tmp,repaint,true);
	}
	
	void SpectrumCanvas::setVisibleArea(AreaType area)
	{
		//cout << __PRETTY_FUNCTION__ << endl;
		changeVisibleArea_(area);
	}
	
	
	void SpectrumCanvas::paintGridLines_(QPainter& painter)
	{	
		if (!show_grid_ || !spectrum_widget_) return;

		QPen p1(QColor(130,130,130));
		p1.setStyle(Qt::DashLine);
		QPen p2(QColor(170,170,170));
		p2.setStyle(Qt::DashLine);
		QPen p3(QColor(230,230,230));
		p3.setStyle(Qt::DashLine);
	
		painter.save();

		unsigned int xl, xh, yl, yh; //width/height of the diagram area, x, y coordinates of lo/hi x,y values
	
		xl = 0;
		xh = width();

		yl = height();
		yh = 0;
	
		// drawing of grid lines and associated text	
		for (unsigned int j = 0; j != spectrum_widget_->xAxis()->gridLines().size() ; j++) 
		{
			// style definitions
			switch(j)
			{
				case 0:	// style settings for big intervals 
					painter.setPen(p1);
					break;
				case 1:	// style settings for small intervals
					painter.setPen(p2);
					break;
				case 2: // style settings for smalles intervals
					painter.setPen(p3);
					break;
				default:
					std::cout << "empty vertical grid line vector error!" << std::endl;
					painter.setPen(QPen(QColor(0,0,0)));
					break;
			}

			int x;
			for (std::vector<double>::const_iterator it = spectrum_widget_->xAxis()->gridLines()[j].begin(); it != spectrum_widget_->xAxis()->gridLines()[j].end(); it++) 
			{
				x = static_cast<int>(Math::intervalTransformation(*it, spectrum_widget_->xAxis()->getAxisMinimum(), spectrum_widget_->xAxis()->getAxisMaximum(), xl, xh));
				painter.drawLine(x, yl, x, yh);
			}
		}
		
		for (unsigned int j = 0; j != spectrum_widget_->yAxis()->gridLines().size() ; j++) 
		{

			// style definitions
			switch(j)
			{
				case 0:	// style settings for big intervals 
					painter.setPen(p1);
					break;
				case 1:	// style settings for small intervals
					painter.setPen(p2);
					break;
				case 2: // style settings for smalles intervals
					painter.setPen(p3);
					break;
				default:
					std::cout << "empty vertical grid line vector error!" << std::endl;
					painter.setPen(QPen(QColor(0,0,0)));
					break;
			}

			int y;
			for (std::vector<double>::const_iterator it = spectrum_widget_->yAxis()->gridLines()[j].begin(); it != spectrum_widget_->yAxis()->gridLines()[j].end(); it++) 
			{
				y = static_cast<int>(Math::intervalTransformation(*it, spectrum_widget_->yAxis()->getAxisMinimum(), spectrum_widget_->yAxis()->getAxisMaximum(), yl, yh));
				
				if (!isFlippedVertically())
				{
					painter.drawLine(xl, y, xh, y);
				}
				else // needed for mirrored canvas, makes a slight difference
				{
					painter.drawLine(xl, yl-y, xh, yl-y);
				}
			}
		}
		
		painter.restore();
	}
	
	UInt SpectrumCanvas::activeLayerIndex() const
	{
		return current_layer_;	
	}

	bool SpectrumCanvas::addLayer(ExperimentType& map, const String& filename)
	{	
		layers_.resize(getLayerCount()+1);
		layers_.back().param = param_;
		layers_.back().filename = filename;
		layers_.back().peaks.swap(map);
		layers_.back().type = LayerData::DT_PEAK;
		return finishAdding_();
	}

	bool SpectrumCanvas::addLayer(FeatureMapType& map, const String& filename)
	{
		layers_.resize(layers_.size()+1);
		layers_.back().param = param_;
		layers_.back().filename = filename;
		layers_.back().features.swap(map);
		layers_.back().type = LayerData::DT_FEATURE;

		return finishAdding_();
	}

	void SpectrumCanvas::setLayerName(UInt i, const String& name)
	{ 
		OPENMS_PRECONDITION(i < layers_.size(), "SpectrumCanvas::setLayerName(i,name) index overflow");
	  getLayer_(i).name = name; 
		if (i==0 && spectrum_widget_) spectrum_widget_->setWindowTitle(name.toQString());
	}

	void SpectrumCanvas::changeVisibility(int i, bool b)
	{
		OPENMS_PRECONDITION(i < (int)layers_.size(), "SpectrumCanvas::changeVisibility(i,b) index overflow");
		LayerData& layer = getLayer_(i);
		if (layer.visible!=b)
		{
			layer.visible=b;
			update_buffer_ = true;
			update_(__PRETTY_FUNCTION__);
		}
	}

	void SpectrumCanvas::changeLayerFilterState(int i, bool b)
	{
		OPENMS_PRECONDITION(i < (int)layers_.size(), "SpectrumCanvas::changeVisibility(i,b) index overflow");
		LayerData& layer = getLayer_(i);
		if (layer.filters.isActive()!=b)
		{
			layer.filters.setActive(b);
			update_buffer_ = true;
			update_(__PRETTY_FUNCTION__);
		}
	}

  const DRange<3>& SpectrumCanvas::getDataRange()
  {
  	return overall_data_range_;
  }
	
	void SpectrumCanvas::recalculateRanges_(UInt mz_dim, UInt rt_dim, UInt it_dim)
	{
		overall_data_range_ = DRange<3>::empty;
		DRange<3>::PositionType min = overall_data_range_.min();
		DRange<3>::PositionType max = overall_data_range_.max();
		
		for (UInt layer_index=0; layer_index< getLayerCount(); ++layer_index)
		{
			if (getLayer(layer_index).type==LayerData::DT_PEAK)
			{
				const ExperimentType& peaks = getLayer(layer_index).peaks;
				if (peaks.getMinMZ() < min[mz_dim]) min[mz_dim] = peaks.getMinMZ();
				if (peaks.getMaxMZ() > max[mz_dim]) max[mz_dim] = peaks.getMaxMZ();
				if (peaks.getMinRT() < min[rt_dim]) min[rt_dim] = peaks.getMinRT();
				if (peaks.getMaxRT() > max[rt_dim]) max[rt_dim] = peaks.getMaxRT();
				if (peaks.getMinInt() < min[it_dim]) min[it_dim] = peaks.getMinInt();
				if (peaks.getMaxInt() > max[it_dim]) max[it_dim] = peaks.getMaxInt();
			}
			else
			{
				const FeatureMapType& feat = getLayer(layer_index).features;
				if (feat.getMin()[1] < min[mz_dim]) min[mz_dim] = feat.getMin()[1];
				if (feat.getMax()[1] > max[mz_dim]) max[mz_dim] = feat.getMax()[1];
				if (feat.getMin()[0] < min[rt_dim]) min[rt_dim] = feat.getMin()[0];
				if (feat.getMax()[0] > max[rt_dim]) max[rt_dim] = feat.getMax()[0];
				if (feat.getMinInt() < min[it_dim]) min[it_dim] = feat.getMinInt();
				if (feat.getMaxInt() > max[it_dim]) max[it_dim] = feat.getMaxInt();
			}	
		}
		//Add 1% margin to RT in order to display all the data
		DoubleReal margin = 0.01*std::max(1.0, max[rt_dim] - min[rt_dim]);
		min[rt_dim] -= margin;
		max[rt_dim] += margin;
		//Add 1% margin to MZ in order to display all the data
		margin = 0.01*std::max(1.0, max[mz_dim] - min[mz_dim]);
		min[mz_dim] -= margin;
		max[mz_dim] += margin;
		
		overall_data_range_.setMin(min);
		overall_data_range_.setMax(max);
	}

	double SpectrumCanvas::getSnapFactor()
	{
		return snap_factor_;
	}

	void SpectrumCanvas::recalculateSnapFactor_()
	{
		
	}

	void SpectrumCanvas::horizontalScrollBarChange(int /*value*/)
	{
		
	}

	void SpectrumCanvas::verticalScrollBarChange(int /*value*/)
	{
		
	}
	
	void SpectrumCanvas::update_(const char*
#ifdef DEBUG_UPDATE_
			caller_name)
	{
		cout << "Spectrum3DCanvas::update_ from '" << caller_name << "'" << endl;
#else
		)
	{
#endif
		update();
	}
	
	void SpectrumCanvas::currentLayerParamtersChanged_()
	{
	}

	void SpectrumCanvas::fileChanged_(const String& filename)
  {
		//look up all layers that contain data of the file
		UInt updatable_layers = 0;
		for (UInt j=0; j<getLayerCount(); ++j)
		{	
			//cout << "  Layer: " << j << " " << getLayer(j).filename << endl;
			if (getLayer(j).filename == filename)
			{
				++updatable_layers;
				bool update = false;
				if ((String)(param_.getValue("on_file_change"))=="update automatically") //automatically update
				{
					update = true;
				}
				else if ((String)(param_.getValue("on_file_change"))=="ask") //ask the user if the layer should be updated
				{
					QMessageBox msg_box;
					QAbstractButton* ok = msg_box.addButton(QMessageBox::Ok);
					msg_box.addButton(QMessageBox::Cancel);
					msg_box.setWindowTitle("Layer data changed");
					msg_box.setText((String("The data file of layer '") + getLayer(j).filename + "' has changed.<BR>Update the layer?").toQString());
					msg_box.exec();
					if (msg_box.clickedButton() == ok)
					{
						update = true;
					}
				}
				//update the layer if the user choosed to do so
				if (update)
				{
					emit sendStatusMessage(String("Updating layer '") + getLayer(j).name + "' (file changed).",0);
					updateLayer_(j);
					emit sendStatusMessage(String("Finished updating layer '") + getLayer(j).name + "'.",5000);
				}
			}
		}
		//remove watchers that are not needed anymore
  	if (updatable_layers==0)
  	{
  		watcher_->removeFile(filename);
  	}  			
	}

	void SpectrumCanvas::focusOutEvent(QFocusEvent* /*e*/)
	{
		// Alt/Shift pressed and focus lost => change back action mode
		if (action_mode_!=AM_TRANSLATE)
		{
			action_mode_ = AM_TRANSLATE;
			emit actionModeChange();
		}
		
		//release Keyboard when loosing focus
	}

	void SpectrumCanvas::leaveEvent(QEvent* /*e*/)
	{
		//grab keyboard, as we need to handle key presses
		releaseKeyboard();
	}

	void SpectrumCanvas::enterEvent(QEvent* /*e*/)
	{
		//release keyboard, when the mouse pointer leaves
		grabKeyboard();
	}

	void SpectrumCanvas::keyReleaseEvent(QKeyEvent* e)
	{
		// Alt/Shift released => change back action mode
		if (e->key()==Qt::Key_Control || e->key()==Qt::Key_Shift)
		{
			action_mode_ = AM_TRANSLATE;
			emit actionModeChange();
		}
	}

	void SpectrumCanvas::keyPressEvent(QKeyEvent* e)
	{
		// Alt/Shift pressed => change action mode
		if (e->key()==Qt::Key_Control)
		{
			action_mode_ = AM_ZOOM;
			emit actionModeChange();
		}
		else if (e->key()==Qt::Key_Shift)
		{
			action_mode_ = AM_MEASURE;
			emit actionModeChange();
		}
		
		// CTRL+/CTRL- => Zoom stack
		if ((e->modifiers() & Qt::ControlModifier) && (e->key()==Qt::Key_Plus))
		{
			zoomForward_();
		}
		else if ((e->modifiers() & Qt::ControlModifier) && (e->key()==Qt::Key_Minus))
		{
			zoomBack_();
		}
		
		// Arrow keys => translate
		else if (e->key()==Qt::Key_Left)
		{
			translateLeft_();
		}
		else if (e->key()==Qt::Key_Right)
		{
			translateRight_();
		}
		else if (e->key()==Qt::Key_Up)
		{
			translateForward_();
		}
		else if (e->key()==Qt::Key_Down)
		{
			translateBackward_();
		}
		
		//Backspace to reset zoom
		else if (e->key()==Qt::Key_Backspace)
		{
			resetZoom();
		}
		
		e->ignore();
	}

	void SpectrumCanvas::translateLeft_()
	{
	}
	
	void SpectrumCanvas::translateRight_()
	{
	}
	
	void SpectrumCanvas::translateForward_()
	{
	}
	
	void SpectrumCanvas::translateBackward_()
	{
	}

	void SpectrumCanvas::setAdditionalContextMenu(QMenu* menu)
	{
	  context_add_ = menu;
	}
	
	void SpectrumCanvas::getVisiblePeakData(ExperimentType& map) const
	{		
		//clear output experiment
		map.clear();
		
    const LayerData& layer = getCurrentLayer();
  	if (layer.type==LayerData::DT_PEAK)
  	{
			const AreaType& area = getVisibleArea();
			const ExperimentType& peaks = layer.peaks;
			//copy experimental settings
			map.ExperimentalSettings::operator=(peaks);
			//reserve space for the correct number of spectra in RT range
			ExperimentType::ConstIterator begin = layer.peaks.RTBegin(area.min()[1]);
			ExperimentType::ConstIterator end = layer.peaks.RTEnd(area.max()[1]);
			//Exception for Spectrum1DCanvas, here we simply copy all spectra
			if (getName()=="Spectrum1DCanvas")
			{
				begin = layer.peaks.begin();
				end = layer.peaks.end();
			}

			map.reserve(end-begin);
			//copy spectra
  		for (ExperimentType::ConstIterator it=begin; it!=end; ++it)
  		{
  			SpectrumType spectrum;
				//copy spectrum meta information
				spectrum.SpectrumSettings::operator=(*it);
				spectrum.setRT(it->getRT());
				spectrum.setMSLevel(it->getMSLevel());
				spectrum.setPrecursorPeak(it->getPrecursorPeak());
				//copy peak information
				for (SpectrumType::ConstIterator it2 = it->MZBegin(area.min()[0]); it2!= it->MZEnd(area.max()[0]); ++it2)
				{
					if (layer.filters.passes(*it,it2-it->begin()))
					{
						spectrum.push_back(*it2);
					}
				}
				map.push_back(spectrum);
  		}
		}
	}

	void SpectrumCanvas::getVisibleFeatureData(FeatureMapType& map) const
	{		
		//clear output experiment
		map.clear();
		
    const LayerData& layer = getCurrentLayer();
  	if (layer.type==LayerData::DT_FEATURE)
  	{
			//copy experimental settings
			map.ExperimentalSettings::operator=(layer.features);
			//Visible area
			DoubleReal min_rt = getVisibleArea().min()[1];
			DoubleReal max_rt = getVisibleArea().max()[1];
			DoubleReal min_mz = getVisibleArea().min()[0];
			DoubleReal max_mz = getVisibleArea().max()[0];
			//copy features
  		for (FeatureMapType::ConstIterator it=layer.features.begin(); it!=layer.features.end(); ++it)
  		{
				if ( layer.filters.passes(*it) 
					&& it->getRT() >= min_rt 
					&& it->getRT() <= max_rt 
					&& it->getMZ() >= min_mz 
					&& it->getMZ() <= max_mz )
				{
					map.push_back(*it);
				}
			}
		}
	}


	void SpectrumCanvas::showMetaData(bool modifiable)
  {
		LayerData& layer = getCurrentLayer_();
		
		MSMetaDataExplorer dlg(modifiable, this);
    dlg.setWindowTitle("Layer meta data");
		if (layer.type==LayerData::DT_PEAK)
  	{
  		dlg.visualize(layer.peaks);
			//Exception for Spectrum1DCanvas, here we add the meta data of the one spectrum
			if (getName()=="Spectrum1DCanvas")
			{
				dlg.visualize(static_cast<SpectrumSettings&>(layer.peaks[0]));
			}
  	}
  	else
  	{
  		dlg.visualize(layer.features);
  	}
    dlg.exec();
  }
	
	void SpectrumCanvas::updateCursor_()
	{
		switch(action_mode_)
		{
			case AM_TRANSLATE:
				setCursor(QCursor(QPixmap(cursor_move),0,0));
				break;
			case AM_ZOOM:
				setCursor(QCursor(QPixmap(cursor_zoom),0,0));
				break;
			case AM_MEASURE:
				setCursor(QCursor(QPixmap(cursor_measure),0,0));
				break;
		}
	}

	
} //namespace


