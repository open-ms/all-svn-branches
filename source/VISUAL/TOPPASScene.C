// -*- mode: C++; tab-width: 2; -*-
// vi: set ts=2:
//
// --------------------------------------------------------------------------
//                   OpenMS Mass Spectrometry Framework 
// --------------------------------------------------------------------------
//  Copyright (C) 2003-2009 -- Oliver Kohlbacher, Knut Reinert
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
// $Maintainer: Johannes Junker $
// $Authors: Johannes Junker $
// --------------------------------------------------------------------------

#include <OpenMS/VISUAL/TOPPASScene.h>
#include <OpenMS/VISUAL/TOPPASVertex.h>
#include <OpenMS/VISUAL/TOPPASInputVertex.h>
#include <OpenMS/VISUAL/TOPPASEdge.h>

namespace OpenMS
{
	
	TOPPASScene::TOPPASScene()
		:	QGraphicsScene(),
			action_mode_(AM_NEW_EDGE),
			vertices_(),
			edges_(),
			hover_edge_(0),
			potential_target_(0)
	{
	}
	
	TOPPASScene::~TOPPASScene()
	{
		// Qt should clean up for us..
	}
	
	void TOPPASScene::setActionMode(ActionMode mode)
	{
		action_mode_ = mode;
	}
	
	TOPPASScene::ActionMode TOPPASScene::getActionMode()
	{
		return action_mode_;
	}
	
	TOPPASScene::VertexIterator TOPPASScene::verticesBegin()
	{
		return vertices_.begin();
	}
	
	TOPPASScene::VertexIterator TOPPASScene::verticesEnd()
	{
		return vertices_.end();
	}
	
	TOPPASScene::EdgeIterator TOPPASScene::edgesBegin()
	{
		return edges_.begin();
	}
	
	TOPPASScene::EdgeIterator TOPPASScene::edgesEnd()
	{
		return edges_.end();
	}
	
	void TOPPASScene::addVertex(TOPPASVertex* tv)
	{
		vertices_.push_back(tv);
		addItem(tv);
	}
	
	void TOPPASScene::addEdge(TOPPASEdge* te)
	{
		edges_.push_back(te);
		addItem(te);
	}
	
	void TOPPASScene::itemClicked()
	{
		TOPPASVertex* sender = qobject_cast<TOPPASVertex*>(QObject::sender());
		if (!sender)
		{
			return;
		}
		bool was_selected = sender->isSelected();
		foreach (QGraphicsItem* item, items())
		{
			item->setSelected(false);
		}
		sender->setSelected(was_selected);
	}
	
	void TOPPASScene::itemDoubleClicked()
	{
		std::cout << "double click!" << std::endl;
	}
	
	void TOPPASScene::updateHoveringEdgePos(const QPointF& new_pos)
	{
		if (!hover_edge_)
		{
			return;
		}
		
		hover_edge_->setHoverPos(new_pos);
		
		TOPPASVertex* target = getVertexAt_(new_pos);
		if (target)
		{
			if (target != potential_target_)
			{
				potential_target_ = target;
				EdgeValidity ev = getEdgeValidity_(hover_edge_->getSourceVertex(), target);
				if (ev == EV_GREEN)
				{
					hover_edge_->setColor(Qt::green);
				}
				else if (ev == EV_YELLOW)
				{
					hover_edge_->setColor(Qt::yellow);
				}
				else // EV_RED
				{
					hover_edge_->setColor(Qt::red);
				}
			}
		}
		else
		{
			hover_edge_->setColor(Qt::black);
			potential_target_ = 0;
		}
	}
	
	void TOPPASScene::addHoveringEdge(const QPointF& pos)
	{
		TOPPASVertex* sender = qobject_cast<TOPPASVertex*>(QObject::sender());
		if (!sender)
		{
			return;
		}
		TOPPASEdge* new_edge = new TOPPASEdge(sender, pos);
		hover_edge_ = new_edge;
		addEdge(new_edge);
	}
	
	void TOPPASScene::finishHoveringEdge()
	{
		TOPPASVertex* target = getVertexAt_(hover_edge_->endPos());
		
		if (target && 
				target != hover_edge_->getSourceVertex() &&
				!(getEdgeValidity_(hover_edge_->getSourceVertex(), target) == EV_RED))
		{
			hover_edge_->setTargetVertex(target);
			TOPPASVertex* source = hover_edge_->getSourceVertex();
			source->addOutEdge(hover_edge_);
			target->addInEdge(hover_edge_);
		}
		else
		{
			if (hover_edge_ != 0)
			{
				edges_.removeAll(hover_edge_);
				removeItem(hover_edge_);
				delete hover_edge_;
				hover_edge_ = 0;
			}
		}
		
		update();
	}
	
	TOPPASVertex* TOPPASScene::getVertexAt_(const QPointF& pos)
	{
		QList<QGraphicsItem*> target_list = items(pos);
		
		// return first item that is a vertex
		TOPPASVertex* target = 0;
		for (QList<QGraphicsItem*>::iterator it = target_list.begin(); it != target_list.end(); ++it)
		{
			target = dynamic_cast<TOPPASVertex*>(*it);
			if (target)
			{
				break;
			}
		}
		
		return target;
	}
	
	void TOPPASScene::removeSelected()
	{
		QList<TOPPASVertex*> vertices_to_be_removed;
		for (VertexIterator it = verticesBegin(); it != verticesEnd(); ++it)
		{
			if ((*it)->isSelected())
			{
				// also select all in and out edges (will be deleted below)
				for (TOPPASVertex::EdgeIterator e_it = (*it)->inEdgesBegin(); e_it != (*it)->inEdgesEnd(); ++e_it)
				{
					(*e_it)->setSelected(true);
				}
				for (TOPPASVertex::EdgeIterator e_it = (*it)->outEdgesBegin(); e_it != (*it)->outEdgesEnd(); ++e_it)
				{
					(*e_it)->setSelected(true);
				}
				vertices_to_be_removed.push_back(*it);
			}
		}
		QList<TOPPASEdge*> edges_to_be_removed;
		for (EdgeIterator it = edgesBegin(); it != edgesEnd(); ++it)
		{
			if ((*it)->isSelected())
			{
				edges_to_be_removed.push_back(*it);
			}
		}

		TOPPASEdge* edge;
		foreach (edge, edges_to_be_removed)
		{
			edges_.removeAll(edge);
			removeItem(edge); // remove from scene 
			delete edge;
		}
		TOPPASVertex* vertex;
		foreach (vertex, vertices_to_be_removed)
		{
			vertices_.removeAll(vertex);
			removeItem(vertex); // remove from scene
			delete vertex;
		}
	}
	
	TOPPASScene::EdgeValidity TOPPASScene::getEdgeValidity_(TOPPASVertex* u, TOPPASVertex* v)
	{
		if (u == 0 || v == 0 || u == v || qobject_cast<TOPPASInputVertex*>(v))
		{
			return EV_RED;
		}
		
		//insert edge between u and v for testing, is removed afterwards
		TOPPASEdge* test_edge = new TOPPASEdge(u,QPointF());
		test_edge->setTargetVertex(v);
		u->addOutEdge(test_edge);
		v->addInEdge(test_edge);
		addEdge(test_edge);
		
		bool graph_has_cycles = false;
		//DFS
		foreach (TOPPASVertex* vertex, vertices_)
		{
			vertex->setDFSColor(TOPPASVertex::DFS_WHITE);
			vertex->setDFSParent(0);
		}
		foreach (TOPPASVertex* vertex, vertices_)
		{
			if (vertex->getDFSColor() == TOPPASVertex::DFS_WHITE)
			{
				graph_has_cycles = dfsVisit_(vertex);
				if (graph_has_cycles)
				{
					break;
				}
			}
		}
		// remove priorly inserted edge
		edges_.removeAll(test_edge);
		removeItem(test_edge);
		delete test_edge;
		
		if (graph_has_cycles)
		{
			return EV_RED;
		}
		else if (false)
		{
			return EV_YELLOW;
		}
		else
		{
			return EV_GREEN;
		}
	}
	
	bool TOPPASScene::dfsVisit_(TOPPASVertex* vertex)
	{
		vertex->setDFSColor(TOPPASVertex::DFS_GRAY);
		for (TOPPASVertex::EdgeIterator it = vertex->outEdgesBegin(); it != vertex->outEdgesEnd(); ++it)
		{
			TOPPASVertex* target = (*it)->getTargetVertex();
			if (target->getDFSColor() == TOPPASVertex::DFS_WHITE)
			{
				target->setDFSParent(vertex);
				if (dfsVisit_(target))
				{
					// back edge found
					return true;
				}
			}
			else if (target->getDFSColor() == TOPPASVertex::DFS_GRAY)
			{
				// back edge found
				return true;
			}
		}
		vertex->setDFSColor(TOPPASVertex::DFS_BLACK);
		return false;
	}

	
} //namespace OpenMS

